{
  "decisions": {},
  "file_index": {
    "Cargo.toml": {
      "path": "Cargo.toml",
      "outline": "",
      "hash": "6e48bb8cf8ff4582",
      "lines": 97,
      "language": ".toml"
    },
    "core/Cargo.toml": {
      "path": "core/Cargo.toml",
      "outline": "",
      "hash": "b5be9ecdf97ebbde",
      "lines": 98,
      "language": ".toml"
    },
    "core/runtime/jsrealm.rs": {
      "path": "core/runtime/jsrealm.rs",
      "outline": "use super::exception_state::ExceptionState;\nuse super::op_driver::OpDriver;\nuse crate::_ops::OpMethodDecl;\nuse crate::ModuleSourceCode;\nuse crate::SourceCodeCacheInfo;\nuse crate::cppgc::FunctionTemplateData;\nuse crate::error::CoreError;\nuse crate::error::CreateCodeCacheError;\nuse crate::error::JsError;\nuse crate::error::exception_to_err;\nuse crate::error::exception_to_err_result;\nuse crate::module_specifier::ModuleSpecifier;\nuse crate::modules::IntoModuleCodeString;\nuse crate::modules::IntoModuleName;\nuse crate::modules::ModuleCodeString;\nuse crate::modules::ModuleId;\nuse crate::modules::ModuleMap;\nuse crate::modules::ModuleName;\nuse crate::modules::script_origin;\nuse crate::ops::ExternalOpsTracker;\nuse crate::ops::OpCtx;\nuse crate::stats::RuntimeActivityTraces;\nuse crate::event_loop::EventLoopPhases;\nuse crate::reactor::DefaultReactor;\nuse crate::uv_compat::UvLoopInner;\nuse crate::tasks::V8TaskSpawnerFactory;\nuse crate::web_timeout::WebTimers;\nuse futures::stream::StreamExt;\nuse std::cell::Cell;\nuse std::cell::RefCell;\nuse std::collections::HashSet;\nuse std::hash::BuildHasherDefault;\nuse std::hash::Hasher;\nuse std::rc::Rc;\nuse std::sync::Arc;\nimpl Hasher for IdentityHasher {\n  fn write_i32(\u0026mut self, i: i32) {\n  fn finish(\u0026self) -\u003e u64 {\n  fn write(\u0026mut self, _bytes: \u0026[u8]) {\npub struct ContextState {\nimpl ContextState {\nimpl JsRealmInner {\n  pub fn context(\u0026self) -\u003e \u0026v8::Global\u003cv8::Context\u003e {\n  pub fn destroy(self) {\nimpl JsRealm {\n  pub fn num_pending_ops(\u0026self) -\u003e usize {\n  pub fn num_unrefed_ops(\u0026self) -\u003e usize {\n  pub fn context(\u0026self) -\u003e \u0026v8::Global\u003cv8::Context\u003e {\n  pub fn execute_script(\n  pub fn execute_script_with_cache(\n  pub fn get_module_namespace(\n",
      "hash": "00c84b5529221f09",
      "lines": 19,
      "language": ".rs"
    },
    "core/runtime/jsruntime.rs": {
      "path": "core/runtime/jsruntime.rs",
      "outline": "use super::SnapshotStoreDataStore;\nuse super::SnapshottedData;\nuse super::bindings;\nuse super::bindings::create_exports_for_ops_virtual_module;\nuse super::bindings::watch_promise;\nuse super::exception_state::ExceptionState;\nuse super::jsrealm::JsRealmInner;\nuse super::op_driver::OpDriver;\nuse super::setup;\nuse super::snapshot;\nuse super::stats::RuntimeActivityStatsFactory;\nuse super::v8_static_strings::*;\nuse crate::Extension;\nuse crate::ExtensionArguments;\nuse crate::ExtensionFileSource;\nuse crate::ExtensionFileSourceCode;\nuse crate::FastStaticString;\nuse crate::FastString;\nuse crate::ModuleCodeString;\nuse crate::NoopModuleLoader;\nuse crate::OpMetadata;\nuse crate::OpMetricsEvent;\nuse crate::OpStackTraceCallback;\nuse crate::OpState;\nuse crate::ascii_str;\nuse crate::ascii_str_include;\nuse crate::cppgc::FunctionTemplateData;\nuse crate::error::CoreError;\nuse crate::error::CoreErrorKind;\nuse crate::error::CoreModuleExecuteError;\nuse crate::error::CoreModuleParseError;\nuse crate::error::ExtensionLazyInitCountMismatchError;\nuse crate::error::ExtensionLazyInitOrderMismatchError;\nuse crate::error::JsError;\nuse crate::error::exception_to_err_result;\nuse crate::extension_set;\nuse crate::extension_set::LoadedSources;\nuse crate::extensions::GlobalObjectMiddlewareFn;\nuse crate::extensions::GlobalTemplateMiddlewareFn;\nuse crate::inspector::JsRuntimeInspector;\nuse crate::module_specifier::ModuleSpecifier;\nuse crate::modules::CustomModuleEvaluationCb;\nuse crate::modules::EvalContextCodeCacheReadyCb;\nuse crate::modules::EvalContextGetCodeCacheCb;\nuse crate::modules::ExtCodeCache;\nuse crate::modules::ExtModuleLoader;\nuse crate::modules::IntoModuleCodeString;\nuse crate::modules::IntoModuleName;\nuse crate::modules::ModuleId;\nuse crate::modules::ModuleLoader;\nuse crate::modules::ModuleMap;\nuse crate::modules::ModuleName;\nuse crate::modules::RequestedModuleType;\nuse crate::modules::ValidateImportAttributesCb;\nuse crate::modules::script_origin;\nuse crate::ops_metrics::OpMetricsFactoryFn;\nuse crate::ops_metrics::dispatch_metrics_async;\nuse crate::runtime::ContextState;\nuse crate::runtime::JsRealm;\nuse crate::runtime::OpDriverImpl;\nuse crate::runtime::jsrealm;\nuse crate::source_map::SourceMapData;\nuse crate::source_map::SourceMapper;\nuse crate::stats::RuntimeActivityType;\nuse deno_error::JsErrorBox;\nuse futures::FutureExt;\nuse futures::task::AtomicWaker;\nuse smallvec::SmallVec;\nuse std::any::Any;\nuse std::future::Future;\nuse std::future::poll_fn;\nuse std::cell::Cell;\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::collections::VecDeque;\nuse std::ffi::c_void;\nuse std::mem::ManuallyDrop;\nuse std::ops::Deref;\nuse std::ops::DerefMut;\nuse std::pin::Pin;\nuse std::rc::Rc;\nuse std::sync::Arc;\nuse std::sync::Mutex;\nuse std::task::Context;\nuse std::task::Poll;\nuse std::task::Waker;\n  pub fn clone(\u0026self) -\u003e Rc\u003cT\u003e {\n  fn deref(\u0026self) -\u003e \u0026Self::Target {\n  fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\nimpl InnerIsolateState {\n  pub fn prepare_for_cleanup(\u0026mut self) {\n  pub fn cleanup(\u0026mut self) {\n  pub fn prepare_for_snapshot(mut self) -\u003e v8::OwnedIsolate {\nimpl Drop for InnerIsolateState {\n  fn drop(\u0026mut self) {\nimpl InitMode {\n  fn from_options(options: \u0026RuntimeOptions) -\u003e Self {\n  pub fn needs_ops_bindings(\u0026self) -\u003e bool {\nstruct PromiseFuture {\nstruct RcPromiseFuture(Rc\u003cPromiseFuture\u003e);\nimpl RcPromiseFuture {\n  pub fn new(res: Result\u003cv8::Global\u003cv8::Value\u003e, Box\u003cJsError\u003e\u003e) -\u003e Self {\nimpl Future for RcPromiseFuture {\n  fn poll(self: Pin\u003c\u0026mut Self\u003e, cx: \u0026mut Context\u003c'_\u003e) -\u003e Poll\u003cSelf::Output\u003e {\npub struct JsRuntime {\npub struct JsRuntimeForSnapshot(JsRuntime);\nimpl Deref for JsRuntimeForSnapshot {\n  fn deref(\u0026self) -\u003e \u0026Self::Target {\nimpl DerefMut for JsRuntimeForSnapshot {\n  fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\npub struct CrossIsolateStore\u003cT\u003e(Arc\u003cMutex\u003cCrossIsolateStoreInner\u003cT\u003e\u003e\u003e);\nstruct CrossIsolateStoreInner\u003cT\u003e {\n  fn default() -\u003e Self {\n  fn clone(\u0026self) -\u003e Self {\npub struct JsRuntimeState {\npub struct RuntimeOptions {\nimpl RuntimeOptions {\n  fn unsafe_expose_natives_and_gc(\u0026self) -\u003e bool {\n  fn unsafe_expose_natives_and_gc(\u0026self) -\u003e bool {\npub struct PollEventLoopOptions {\nimpl Default for PollEventLoopOptions {\n  fn default() -\u003e Self {\npub struct CreateRealmOptions {\nimpl JsRuntime {\n  pub fn init_platform(v8_platform: Option\u003cv8::SharedRef\u003cv8::Platform\u003e\u003e) {\n  pub fn init_platform(\n  pub fn new(options: RuntimeOptions) -\u003e JsRuntime {\n  pub fn try_new(mut options: RuntimeOptions) -\u003e Result\u003cJsRuntime, CoreError\u003e {\n  pub fn op_state_from(isolate: \u0026v8::Isolate) -\u003e Rc\u003cRefCell\u003cOpState\u003e\u003e {\n  pub fn op_metadata(\u0026self, name: \u0026str) -\u003e Option\u003cOpMetadata\u003e {\n  fn new_inner(\n  pub fn lazy_init_extensions(\n  pub fn set_eval_context_code_cache_cbs(\n  pub fn main_context(\u0026self) -\u003e v8::Global\u003cv8::Context\u003e {\n  pub fn v8_isolate(\u0026mut self) -\u003e \u0026mut v8::OwnedIsolate {\n  fn v8_isolate_ptr(\u0026mut self) -\u003e v8::UnsafeRawIsolatePtr {\n  pub fn inspector(\u0026self) -\u003e Rc\u003cJsRuntimeInspector\u003e {\n  pub fn wait_for_inspector_disconnect(\u0026self) {\n  pub fn runtime_activity_stats_factory(\u0026self) -\u003e RuntimeActivityStatsFactory {\n  fn execute_virtual_ops_module(\n  fn execute_builtin_sources(\n  fn init_extension_js(\n  pub fn eval\u003c's, 'i, T\u003e(\n  fn store_js_callbacks(\u0026mut self, realm: \u0026JsRealm, will_snapshot: bool) {\n  pub fn op_state(\u0026self) -\u003e Rc\u003cRefCell\u003cOpState\u003e\u003e {\n  pub fn op_names(\u0026self) -\u003e Vec\u003c\u0026'static str\u003e {\n  pub fn execute_script(\n  pub fn call(\n  pub fn scoped_call(\n  pub fn call_with_args(\n  pub fn scoped_call_with_args(\n  pub fn get_module_namespace(\n  pub fn add_near_heap_limit_callback\u003cC\u003e(\u0026mut self, cb: C)\n  pub fn remove_near_heap_limit_callback(\u0026mut self, heap_limit: usize) {\n  fn pump_v8_message_loop(\n  pub fn maybe_init_inspector(\u0026mut self) {\n  pub fn resolve(\n  pub fn scoped_resolve(\n  fn resolve_promise_inner\u003c's, 'i\u003e(\n  pub fn poll_event_loop(\n  fn poll_event_loop_inner(\nfn find_and_report_stalled_level_await_in_any_realm(\nfn create_context\u003c's, 'i\u003e(\nimpl JsRuntimeForSnapshot {\n  pub fn new(options: RuntimeOptions) -\u003e JsRuntimeForSnapshot {\n  pub fn try_new(\n  pub fn snapshot(mut self) -\u003e Box\u003c[u8]\u003e {\nimpl EventLoopPendingState {\n  pub fn new(\n  pub fn new_from_scope(scope: \u0026mut v8::PinScope) -\u003e Self {\n  pub fn is_pending(\u0026self) -\u003e bool {\nimpl JsRuntimeState {\n  pub fn notify_new_dynamic_import(\u0026self) {\nimpl JsRuntime {\n  pub fn mod_evaluate(\n  pub fn lazy_load_es_module_with_code(\n  fn do_js_run_immediate_callbacks\u003c's, 'i\u003e(\n  fn dispatch_timers\u003c's, 'i\u003e(\n  fn dispatch_task_spawner(\n  fn dispatch_pending_ops\u003c's, 'i\u003e(\n  fn dispatch_rejections\u003c's, 'i\u003e(\n  fn drain_next_tick_and_macrotasks\u003c's, 'i\u003e(\nfn mark_as_loaded_from_fs_during_snapshot(\n",
      "hash": "e269ebf5a435b1c1",
      "lines": 21,
      "language": ".rs"
    },
    "core/uv_compat.rs": {
      "path": "core/uv_compat.rs",
      "outline": "use std::cell::Cell;\nuse std::cell::RefCell;\nuse std::collections::BTreeSet;\nuse std::collections::HashMap;\nuse std::collections::VecDeque;\nuse std::ffi::c_char;\nuse std::ffi::c_int;\nuse std::ffi::c_void;\nuse std::time::Duration;\nuse std::time::Instant;\npub struct uv_loop_t {\npub struct uv_handle_t {\npub struct uv_timer_t {\npub struct uv_idle_t {\npub struct uv_prepare_t {\npub struct uv_check_t {\npub struct uv_stream_t {\npub struct uv_tcp_t {\npub struct uv_write_t {\npub struct uv_buf_t {\nstruct TimerKey {\nimpl UvLoopInner {\n  fn new() -\u003e Self {\n  fn alloc_timer_id(\u0026self) -\u003e u64 {\n  fn now_ms(\u0026self) -\u003e u64 {\n  fn has_alive_handles(\u0026self) -\u003e bool {\n  fn next_timer_deadline_ms(\u0026self) -\u003e Option\u003cu64\u003e {\n  fn stop_idle(\u0026self, handle: *mut uv_idle_t) {\n  fn stop_prepare(\u0026self, handle: *mut uv_prepare_t) {\n  fn stop_check(\u0026self, handle: *mut uv_check_t) {\nmod tests {\n  use super::*;\n  use std::mem::MaybeUninit;\n  use std::sync::atomic::{AtomicU32, AtomicBool, Ordering};\n  fn test_loop_init_close() {\n  fn test_timer_fires() {\n  fn test_repeat_timer() {\n  fn test_idle_fires() {\n  fn test_prepare_check_order() {\n  fn test_close_callback() {\n  fn test_unref_exits_loop() {\n  fn test_stop_breaks_loop() {\n  fn test_timer_again() {\n  fn test_timer_get_set_repeat() {\n  pub fn new_write() -\u003e Box\u003cUvWrite\u003e {\n",
      "hash": "e54be6eb49a91423",
      "lines": 40,
      "language": ".rs"
    }
  },
  "conventions": null,
  "preamble": "Project: rust (Cargo.toml)\n\nKey files:\n  core/Cargo.toml (98 lines)\n  Cargo.toml (97 lines)\n  core/uv_compat.rs (40 lines)\n  core/runtime/jsruntime.rs (21 lines)\n  core/runtime/jsrealm.rs (19 lines)\n",
  "total_interactions": 2,
  "tokens_saved": 0,
  "updated": "2026-02-19T20:08:54.32211+05:30"
}