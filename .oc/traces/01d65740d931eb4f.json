{
  "id": "f7e82ee8c5dcb4e4",
  "trigger": "compat deno_core explain how implemented libuv tokio",
  "trigger_id": "01d65740d931eb4f",
  "raw_trigger": "explain how libuv compat is implemented using tokio in deno_core",
  "effects": [
    {
      "tool": "list_files",
      "input": {
        "path": ".}"
      },
      "output": "Error listing directory: open .}: no such file or directory",
      "is_error": true,
      "duration_ms": 0
    },
    {
      "tool": "list_files",
      "input": {
        "path": "."
      },
      "output": ".claude/\n.dprint.json\n.git/\n.gitattributes\n.github/\n.gitignore\n.oc/\n.rustfmt.toml\n.worktrees/\nARCHITECTURE.md\nCargo.lock\nCargo.toml\nLICENSE.md\nREADME.md\ncore/\ndcore/\nops/\nrust-toolchain.toml\nserde_v8/\ntarget/\ntesting/\ntools/\n",
      "is_error": false,
      "duration_ms": 0
    },
    {
      "tool": "read_file",
      "input": {
        "path": "core/uv_compat.rs"
      },
      "output": "// Copyright 2018-2025 the Deno authors. MIT license.\n\n//! libuv-compatible C FFI layer.\n//!\n//! This module provides `extern \"C\"` functions matching libuv's header\n//! signatures for timers, idle, prepare, check, close, and `uv_run`.\n//! Internal Rust types back the C-repr structs, allowing native C/C++\n//! consumers (including Node native addons) to use the event loop directly.\n\nuse std::cell::Cell;\nuse std::cell::RefCell;\nuse std::collections::BTreeSet;\nuse std::collections::HashMap;\nuse std::collections::VecDeque;\nuse std::ffi::c_int;\nuse std::ffi::c_void;\nuse std::time::Duration;\nuse std::time::Instant;\n\n// ---------------------------------------------------------------------------\n// Handle types\n// ---------------------------------------------------------------------------\n\n/// Handle type identifiers, matching libuv's `uv_handle_type`.\n#[repr(C)]\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum uv_handle_type {\n  UV_UNKNOWN_HANDLE = 0,\n  UV_TIMER = 1,\n  UV_IDLE = 2,\n  UV_PREPARE = 3,\n  UV_CHECK = 4,\n}\n\n/// Run mode for `uv_run`, matching libuv's `uv_run_mode`.\n#[repr(C)]\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum uv_run_mode {\n  UV_RUN_DEFAULT = 0,\n  UV_RUN_ONCE = 1,\n  UV_RUN_NOWAIT = 2,\n}\n\n/// Flags stored in handle `flags` field.\nconst UV_HANDLE_ACTIVE: u32 = 1 \u003c\u003c 0;\nconst UV_HANDLE_REF: u32 = 1 \u003c\u003c 1;\nconst UV_HANDLE_CLOSING: u32 = 1 \u003c\u003c 2;\n\n// ---------------------------------------------------------------------------\n// C-repr structs\n// ---------------------------------------------------------------------------\n\n/// Opaque loop handle backed by Rust internals.\n#[repr(C)]\npub struct uv_loop_t {\n  /// Pointer to internal Rust state. Set during init.\n  internal: *mut c_void,\n  /// User-accessible data pointer (matches libuv's `uv_loop_t.data`).\n  pub data: *mut c_void,\n  /// Stop flag, set by `uv_stop`.\n  stop_flag: Cell\u003cbool\u003e,\n}\n\n/// Base handle fields shared by all handle types.\n#[repr(C)]\npub struct uv_handle_t {\n  pub r#type: uv_handle_type,\n  pub loop_: *mut uv_loop_t,\n  pub data: *mut c_void,\n  pub flags: u32,\n}\n\n/// Timer handle.\n#[repr(C)]\npub struct uv_timer_t {\n  // Common handle fields\n  pub r#type: uv_handle_type,\n  pub loop_: *mut uv_loop_t,\n  pub data: *mut c_void,\n  pub flags: u32,\n  // Timer-specific\n  internal_id: u64,\n  internal_deadline: u64,\n  cb: Option\u003cunsafe extern \"C\" fn(*mut uv_timer_t)\u003e,\n  timeout: u64,\n  repeat: u64,\n}\n\n/// Idle handle.\n#[repr(C)]\npub struct uv_idle_t {\n  pub r#type: uv_handle_type,\n  pub loop_: *mut uv_loop_t,\n  pub data: *mut c_void,\n  pub flags: u32,\n  cb: Option\u003cunsafe extern \"C\" fn(*mut uv_idle_t)\u003e,\n}\n\n/// Prepare handle.\n#[repr(C)]\npub struct uv_prepare_t {\n  pub r#type: uv_handle_type,\n  pub loop_: *mut uv_loop_t,\n  pub data: *mut c_void,\n  pub flags: u32,\n  cb: Option\u003cunsafe extern \"C\" fn(*mut uv_prepare_t)\u003e,\n}\n\n/// Check handle.\n#[repr(C)]\npub struct uv_check_t {\n  pub r#type: uv_handle_type,\n  pub loop_: *mut uv_loop_t,\n  pub data: *mut c_void,\n  pub flags: u32,\n  cb: Option\u003cunsafe extern \"C\" fn(*mut uv_check_t)\u003e,\n}\n\n// ---------------------------------------------------------------------------\n// Callback types\n// ---------------------------------------------------------------------------\n\npub type uv_timer_cb = unsafe extern \"C\" fn(*mut uv_timer_t);\npub type uv_idle_cb = unsafe extern \"C\" fn(*mut uv_idle_t);\npub type uv_prepare_cb = unsafe extern \"C\" fn(*mut uv_prepare_t);\npub type uv_check_cb = unsafe extern \"C\" fn(*mut uv_check_t);\npub type uv_close_cb = unsafe extern \"C\" fn(*mut uv_handle_t);\n\n// ---------------------------------------------------------------------------\n// UvLoopInner — internal state behind uv_loop_t.internal\n// ---------------------------------------------------------------------------\n\n/// Key for the timer BTreeSet. Ordered by (deadline_ms, id) so we get\n/// min-heap behavior from BTreeSet iteration.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\nstruct TimerKey {\n  deadline_ms: u64,\n  id: u64,\n}\n\n/// Internal state for a libuv-compatible event loop.\npub(crate) struct UvLoopInner {\n  timers: RefCell\u003cBTreeSet\u003cTimerKey\u003e\u003e,\n  next_timer_id: Cell\u003cu64\u003e,\n  timer_handles: RefCell\u003cHashMap\u003cu64, *mut uv_timer_t\u003e\u003e,\n\n  idle_handles: RefCell\u003cVec\u003c*mut uv_idle_t\u003e\u003e,\n  prepare_handles: RefCell\u003cVec\u003c*mut uv_prepare_t\u003e\u003e,\n  check_handles: RefCell\u003cVec\u003c*mut uv_check_t\u003e\u003e,\n\n  closing_handles:\n    RefCell\u003cVecDeque\u003c(*mut uv_handle_t, Option\u003cuv_close_cb\u003e)\u003e\u003e,\n\n  time_origin: Instant,\n}\n\nimpl UvLoopInner {\n  fn new() -\u003e Self {\n    Self {\n      timers: RefCell::new(BTreeSet::new()),\n      next_timer_id: Cell::new(1),\n      timer_handles: RefCell::new(HashMap::new()),\n      idle_handles: RefCell::new(Vec::new()),\n      prepare_handles: RefCell::new(Vec::new()),\n      check_handles: RefCell::new(Vec::new()),\n      closing_handles: RefCell::new(VecDeque::new()),\n      time_origin: Instant::now(),\n    }\n  }\n\n  fn alloc_timer_id(\u0026self) -\u003e u64 {\n    let id = self.next_timer_id.get();\n    self.next_timer_id.set(id + 1);\n    id\n  }\n\n  fn now_ms(\u0026self) -\u003e u64 {\n    Instant::now().duration_since(self.time_origin).as_millis() as u64\n  }\n\n  /// Drive all libuv phases in order. Used by `uv_run` for standalone\n  /// C-only consumers.\n  ///\n  /// When integrated with `JsRuntime::poll_event_loop_inner`, the individual\n  /// `run_*` methods are called at their corresponding event loop phases\n  /// instead of using this combined tick.\n  ///\n  /// # Safety\n  /// All handle pointers stored in the internal lists must be valid.\n  unsafe fn tick(\u0026self) {\n    unsafe {\n      self.run_timers();\n      self.run_idle();\n      self.run_prepare();\n      self.run_check();\n      self.run_close();\n    }\n  }\n\n  /// Returns true if there are any alive (active + ref'd) handles.\n  fn has_alive_handles(\u0026self) -\u003e bool {\n    // Check timers\n    for (_, handle_ptr) in self.timer_handles.borrow().iter() {\n      let handle = unsafe { \u0026**handle_ptr };\n      if handle.flags \u0026 UV_HANDLE_ACTIVE != 0\n        \u0026\u0026 handle.flags \u0026 UV_HANDLE_REF != 0\n      {\n        return true;\n      }\n    }\n    // Check idle\n    for handle_ptr in self.idle_handles.borrow().iter() {\n      let handle = unsafe { \u0026**handle_ptr };\n      if handle.flags \u0026 UV_HANDLE_ACTIVE != 0\n        \u0026\u0026 handle.flags \u0026 UV_HANDLE_REF != 0\n      {\n        return true;\n      }\n    }\n    // Check prepare\n    for handle_ptr in self.prepare_handles.borrow().iter() {\n      let handle = unsafe { \u0026**handle_ptr };\n      if handle.flags \u0026 UV_HANDLE_ACTIVE != 0\n        \u0026\u0026 handle.flags \u0026 UV_HANDLE_REF != 0\n      {\n        return true;\n      }\n    }\n    // Check check\n    for handle_ptr in self.check_handles.borrow().iter() {\n      let handle = unsafe { \u0026**handle_ptr };\n      if handle.flags \u0026 UV_HANDLE_ACTIVE != 0\n        \u0026\u0026 handle.flags \u0026 UV_HANDLE_REF != 0\n      {\n        return true;\n      }\n    }\n    // Pending close callbacks count as alive\n    if !self.closing_handles.borrow().is_empty() {\n      return true;\n    }\n    false\n  }\n\n  /// Returns the next timer deadline in ms, or None if no timers.\n  fn next_timer_deadline_ms(\u0026self) -\u003e Option\u003cu64\u003e {\n    self.timers.borrow().iter().next().map(|k| k.deadline_ms)\n  }\n\n  /// Fire all expired C timers. Called at Phase 1 (Timers).\n  ///\n  /// # Safety\n  /// All timer handle pointers must be valid.\n  pub(crate) unsafe fn run_timers(\u0026self) {\n    let now = self.now_ms();\n    // Collect expired timers\n    let mut expired = Vec::new();\n    {\n      let timers = self.timers.borrow();\n      for key in timers.iter() {\n        if key.deadline_ms \u003e now {\n          break;\n        }\n        expired.push(*key);\n      }\n    }\n\n    for key in expired {\n      self.timers.borrow_mut().remove(\u0026key);\n      let handle_ptr =\n        match self.timer_handles.borrow().get(\u0026key.id).copied() {\n          Some(h) =\u003e h,\n          None =\u003e continue,\n        };\n      let handle = unsafe { \u0026mut *handle_ptr };\n      // Only fire if still active\n      if handle.flags \u0026 UV_HANDLE_ACTIVE == 0 {\n        self.timer_handles.borrow_mut().remove(\u0026key.id);\n        continue;\n      }\n      let cb = handle.cb;\n      let repeat = handle.repeat;\n\n      if repeat \u003e 0 {\n        // Re-arm repeat timer\n        let new_deadline = now + repeat;\n        let new_key = TimerKey {\n          deadline_ms: new_deadline,\n          id: key.id,\n        };\n        handle.internal_deadline = new_deadline;\n        self.timers.borrow_mut().insert(new_key);\n      } else {\n        // One-shot: deactivate\n        handle.flags \u0026= !UV_HANDLE_ACTIVE;\n        self.timer_handles.borrow_mut().remove(\u0026key.id);\n      }\n\n      if let Some(cb) = cb {\n        unsafe { cb(handle_ptr) };\n      }\n    }\n  }\n\n  /// Fire all active idle callbacks. Called at Phase 3a (Idle).\n  ///\n  /// # Safety\n  /// All idle handle pointers must be valid.\n  pub(crate) unsafe fn run_idle(\u0026self) {\n    let snapshot: Vec\u003c*mut uv_idle_t\u003e =\n      self.idle_handles.borrow().clone();\n    for handle_ptr in snapshot {\n      let handle = unsafe { \u0026*handle_ptr };\n      if handle.flags \u0026 UV_HANDLE_ACTIVE != 0 {\n        if let Some(cb) = handle.cb {\n          unsafe { cb(handle_ptr) };\n        }\n      }\n    }\n  }\n\n  /// Fire all active prepare callbacks. Called at Phase 3b (Prepare).\n  ///\n  /// # Safety\n  /// All prepare handle pointers must be valid.\n  pub(crate) unsafe fn run_prepare(\u0026self) {\n    let snapshot: Vec\u003c*mut uv_prepare_t\u003e =\n      self.prepare_handles.borrow().clone();\n    for handle_ptr in snapshot {\n      let handle = unsafe { \u0026*handle_ptr };\n      if handle.flags \u0026 UV_HANDLE_ACTIVE != 0 {\n        if let Some(cb) = handle.cb {\n          unsafe { cb(handle_ptr) };\n        }\n      }\n    }\n  }\n\n  /// Fire all active check callbacks. Called at Phase 5 (Check).\n  ///\n  /// # Safety\n  /// All check handle pointers must be valid.\n  pub(crate) unsafe fn run_check(\u0026self) {\n    let snapshot: Vec\u003c*mut uv_check_t\u003e =\n      self.check_handles.borrow().clone();\n    for handle_ptr in snapshot {\n      let handle = unsafe { \u0026*handle_ptr };\n      if handle.flags \u0026 UV_HANDLE_ACTIVE != 0 {\n        if let Some(cb) = handle.cb {\n          unsafe { cb(handle_ptr) };\n        }\n      }\n    }\n  }\n\n  /// Drain and fire all queued close callbacks. Called at Phase 6 (Close).\n  ///\n  /// # Safety\n  /// All handle pointers in the closing queue must be valid.\n  pub(crate) unsafe fn run_close(\u0026self) {\n    let mut closing = self.closing_handles.borrow_mut();\n    let snapshot: Vec\u003c_\u003e = closing.drain(..).collect();\n    drop(closing);\n    for (handle_ptr, cb) in snapshot {\n      if let Some(cb) = cb {\n        unsafe { cb(handle_ptr) };\n      }\n    }\n  }\n\n  /// Stop a timer handle and remove it from the inner structures.\n  unsafe fn stop_timer(\u0026self, handle: *mut uv_timer_t) {\n    let handle_ref = unsafe { \u0026mut *handle };\n    let id = handle_ref.internal_id;\n    if id != 0 {\n      let key = TimerKey {\n        deadline_ms: handle_ref.internal_deadline,\n        id,\n      };\n      self.timers.borrow_mut().remove(\u0026key);\n      self.timer_handles.borrow_mut().remove(\u0026id);\n    }\n    handle_ref.flags \u0026= !UV_HANDLE_ACTIVE;\n  }\n\n  fn stop_idle(\u0026self, handle: *mut uv_idle_t) {\n    self\n      .idle_handles\n      .borrow_mut()\n      .retain(|\u0026h| !std::ptr::eq(h, handle));\n    unsafe {\n      (*handle).flags \u0026= !UV_HANDLE_ACTIVE;\n    }\n  }\n\n  fn stop_prepare(\u0026self, handle: *mut uv_prepare_t) {\n    self\n      .prepare_handles\n      .borrow_mut()\n      .retain(|\u0026h| !std::ptr::eq(h, handle));\n    unsafe {\n      (*handle).flags \u0026= !UV_HANDLE_ACTIVE;\n    }\n  }\n\n  fn stop_check(\u0026self, handle: *mut uv_check_t) {\n    self\n      .check_handles\n      .borrow_mut()\n      .retain(|\u0026h| !std::ptr::eq(h, handle));\n    unsafe {\n      (*handle).flags \u0026= !UV_HANDLE_ACTIVE;\n    }\n  }\n}\n\n/// Get the `UvLoopInner` from a `uv_loop_t` pointer.\n///\n/// # Safety\n/// `loop_` must be a valid, initialized loop pointer.\n#[inline]\nunsafe fn get_inner(loop_: *mut uv_loop_t) -\u003e \u0026'static UvLoopInner {\n  unsafe { \u0026*((*loop_).internal as *const UvLoopInner) }\n}\n\n// ---------------------------------------------------------------------------\n// Loop API\n// ---------------------------------------------------------------------------\n\n/// Initialize a loop handle.\n///\n/// # Safety\n/// `loop_` must be a valid, non-null pointer to an uninitialized `uv_loop_t`.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_loop_init(loop_: *mut uv_loop_t) -\u003e c_int {\n  let inner = Box::new(UvLoopInner::new());\n  unsafe {\n    (*loop_).internal = Box::into_raw(inner) as *mut c_void;\n    (*loop_).data = std::ptr::null_mut();\n    (*loop_).stop_flag = Cell::new(false);\n  }\n  0\n}\n\n/// Close and clean up a loop handle.\n///\n/// # Safety\n/// `loop_` must be a valid, initialized loop pointer. No handles should\n/// be active when this is called.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_loop_close(loop_: *mut uv_loop_t) -\u003e c_int {\n  unsafe {\n    let internal = (*loop_).internal;\n    if !internal.is_null() {\n      drop(Box::from_raw(internal as *mut UvLoopInner));\n      (*loop_).internal = std::ptr::null_mut();\n    }\n  }\n  0\n}\n\n/// Signal the loop to stop. The next `uv_run` iteration will exit.\n///\n/// # Safety\n/// `loop_` must be a valid, initialized loop pointer.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_stop(loop_: *mut uv_loop_t) {\n  unsafe {\n    (*loop_).stop_flag.set(true);\n  }\n}\n\n/// Return the current cached time in ms since loop start.\n///\n/// # Safety\n/// `loop_` must be a valid, initialized loop pointer.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_now(loop_: *mut uv_loop_t) -\u003e u64 {\n  let inner = unsafe { get_inner(loop_) };\n  inner.now_ms()\n}\n\n/// Update the cached time. (Currently a no-op since we compute on demand.)\n///\n/// # Safety\n/// `loop_` must be a valid, initialized loop pointer.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_update_time(_loop_: *mut uv_loop_t) {\n  // Time is computed on demand from Instant, no caching needed.\n}\n\n// ---------------------------------------------------------------------------\n// Timer API\n// ---------------------------------------------------------------------------\n\n/// Initialize a timer handle.\n///\n/// # Safety\n/// `loop_` and `handle` must be valid, non-null pointers.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_timer_init(\n  loop_: *mut uv_loop_t,\n  handle: *mut uv_timer_t,\n) -\u003e c_int {\n  unsafe {\n    (*handle).r#type = uv_handle_type::UV_TIMER;\n    (*handle).loop_ = loop_;\n    (*handle).data = std::ptr::null_mut();\n    (*handle).flags = UV_HANDLE_REF;\n    (*handle).internal_id = 0;\n    (*handle).internal_deadline = 0;\n    (*handle).cb = None;\n    (*handle).timeout = 0;\n    (*handle).repeat = 0;\n  }\n  0\n}\n\n/// Start a timer. `timeout` is the initial timeout in ms, `repeat` is the\n/// repeat interval in ms (0 = one-shot).\n///\n/// # Safety\n/// `handle` must have been initialized with `uv_timer_init`.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_timer_start(\n  handle: *mut uv_timer_t,\n  cb: uv_timer_cb,\n  timeout: u64,\n  repeat: u64,\n) -\u003e c_int {\n  unsafe {\n    let loop_ = (*handle).loop_;\n    let inner = get_inner(loop_);\n\n    // If already active, stop first (remove old entry)\n    if (*handle).flags \u0026 UV_HANDLE_ACTIVE != 0 {\n      inner.stop_timer(handle);\n    }\n\n    let id = inner.alloc_timer_id();\n    let deadline = inner.now_ms() + timeout;\n\n    (*handle).cb = Some(cb);\n    (*handle).timeout = timeout;\n    (*handle).repeat = repeat;\n    (*handle).internal_id = id;\n    (*handle).internal_deadline = deadline;\n    (*handle).flags |= UV_HANDLE_ACTIVE;\n\n    let key = TimerKey {\n      deadline_ms: deadline,\n      id,\n    };\n    inner.timers.borrow_mut().insert(key);\n    inner.timer_handles.borrow_mut().insert(id, handle);\n  }\n  0\n}\n\n/// Stop a timer.\n///\n/// # Safety\n/// `handle` must have been initialized with `uv_timer_init`.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_timer_stop(handle: *mut uv_timer_t) -\u003e c_int {\n  unsafe {\n    let loop_ = (*handle).loop_;\n    if loop_.is_null() || (*loop_).internal.is_null() {\n      (*handle).flags \u0026= !UV_HANDLE_ACTIVE;\n      return 0;\n    }\n    let inner = get_inner(loop_);\n    inner.stop_timer(handle);\n  }\n  0\n}\n\n/// Restart a repeat timer. If the timer was not started or has no repeat\n/// interval, this returns UV_EINVAL (-22).\n///\n/// # Safety\n/// `handle` must have been initialized with `uv_timer_init`.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_timer_again(\n  handle: *mut uv_timer_t,\n) -\u003e c_int {\n  unsafe {\n    let repeat = (*handle).repeat;\n    if repeat == 0 {\n      return -22; // UV_EINVAL\n    }\n    let loop_ = (*handle).loop_;\n    let inner = get_inner(loop_);\n\n    // Stop existing\n    inner.stop_timer(handle);\n\n    // Re-arm with repeat as timeout\n    let id = inner.alloc_timer_id();\n    let deadline = inner.now_ms() + repeat;\n\n    (*handle).internal_id = id;\n    (*handle).internal_deadline = deadline;\n    (*handle).flags |= UV_HANDLE_ACTIVE;\n\n    let key = TimerKey {\n      deadline_ms: deadline,\n      id,\n    };\n    inner.timers.borrow_mut().insert(key);\n    inner.timer_handles.borrow_mut().insert(id, handle);\n  }\n  0\n}\n\n/// Get the repeat interval of a timer.\n///\n/// # Safety\n/// `handle` must have been initialized with `uv_timer_init`.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_timer_get_repeat(\n  handle: *const uv_timer_t,\n) -\u003e u64 {\n  unsafe { (*handle).repeat }\n}\n\n/// Set the repeat interval of a timer.\n///\n/// # Safety\n/// `handle` must have been initialized with `uv_timer_init`.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_timer_set_repeat(\n  handle: *mut uv_timer_t,\n  repeat: u64,\n) {\n  unsafe {\n    (*handle).repeat = repeat;\n  }\n}\n\n// ---------------------------------------------------------------------------\n// Idle API\n// ---------------------------------------------------------------------------\n\n/// Initialize an idle handle.\n///\n/// # Safety\n/// `loop_` and `handle` must be valid, non-null pointers.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_idle_init(\n  loop_: *mut uv_loop_t,\n  handle: *mut uv_idle_t,\n) -\u003e c_int {\n  unsafe {\n    (*handle).r#type = uv_handle_type::UV_IDLE;\n    (*handle).loop_ = loop_;\n    (*handle).data = std::ptr::null_mut();\n    (*handle).flags = UV_HANDLE_REF;\n    (*handle).cb = None;\n  }\n  0\n}\n\n/// Start an idle handle.\n///\n/// # Safety\n/// `handle` must have been initialized with `uv_idle_init`.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_idle_start(\n  handle: *mut uv_idle_t,\n  cb: uv_idle_cb,\n) -\u003e c_int {\n  unsafe {\n    // Idempotent: if already active, just update cb\n    if (*handle).flags \u0026 UV_HANDLE_ACTIVE != 0 {\n      (*handle).cb = Some(cb);\n      return 0;\n    }\n    (*handle).cb = Some(cb);\n    (*handle).flags |= UV_HANDLE_ACTIVE;\n\n    let loop_ = (*handle).loop_;\n    let inner = get_inner(loop_);\n    inner.idle_handles.borrow_mut().push(handle);\n  }\n  0\n}\n\n/// Stop an idle handle.\n///\n/// # Safety\n/// `handle` must have been initialized with `uv_idle_init`.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_idle_stop(handle: *mut uv_idle_t) -\u003e c_int {\n  unsafe {\n    if (*handle).flags \u0026 UV_HANDLE_ACTIVE == 0 {\n      return 0;\n    }\n    let loop_ = (*handle).loop_;\n    let inner = get_inner(loop_);\n    inner.stop_idle(handle);\n    (*handle).cb = None;\n  }\n  0\n}\n\n// ---------------------------------------------------------------------------\n// Prepare API\n// ---------------------------------------------------------------------------\n\n/// Initialize a prepare handle.\n///\n/// # Safety\n/// `loop_` and `handle` must be valid, non-null pointers.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_prepare_init(\n  loop_: *mut uv_loop_t,\n  handle: *mut uv_prepare_t,\n) -\u003e c_int {\n  unsafe {\n    (*handle).r#type = uv_handle_type::UV_PREPARE;\n    (*handle).loop_ = loop_;\n    (*handle).data = std::ptr::null_mut();\n    (*handle).flags = UV_HANDLE_REF;\n    (*handle).cb = None;\n  }\n  0\n}\n\n/// Start a prepare handle.\n///\n/// # Safety\n/// `handle` must have been initialized with `uv_prepare_init`.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_prepare_start(\n  handle: *mut uv_prepare_t,\n  cb: uv_prepare_cb,\n) -\u003e c_int {\n  unsafe {\n    if (*handle).flags \u0026 UV_HANDLE_ACTIVE != 0 {\n      (*handle).cb = Some(cb);\n      return 0;\n    }\n    (*handle).cb = Some(cb);\n    (*handle).flags |= UV_HANDLE_ACTIVE;\n\n    let loop_ = (*handle).loop_;\n    let inner = get_inner(loop_);\n    inner.prepare_handles.borrow_mut().push(handle);\n  }\n  0\n}\n\n/// Stop a prepare handle.\n///\n/// # Safety\n/// `handle` must have been initialized with `uv_prepare_init`.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_prepare_stop(\n  handle: *mut uv_prepare_t,\n) -\u003e c_int {\n  unsafe {\n    if (*handle).flags \u0026 UV_HANDLE_ACTIVE == 0 {\n      return 0;\n    }\n    let loop_ = (*handle).loop_;\n    let inner = get_inner(loop_);\n    inner.stop_prepare(handle);\n    (*handle).cb = None;\n  }\n  0\n}\n\n// ---------------------------------------------------------------------------\n// Check API\n// ---------------------------------------------------------------------------\n\n/// Initialize a check handle.\n///\n/// # Safety\n/// `loop_` and `handle` must be valid, non-null pointers.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_check_init(\n  loop_: *mut uv_loop_t,\n  handle: *mut uv_check_t,\n) -\u003e c_int {\n  unsafe {\n    (*handle).r#type = uv_handle_type::UV_CHECK;\n    (*handle).loop_ = loop_;\n    (*handle).data = std::ptr::null_mut();\n    (*handle).flags = UV_HANDLE_REF;\n    (*handle).cb = None;\n  }\n  0\n}\n\n/// Start a check handle.\n///\n/// # Safety\n/// `handle` must have been initialized with `uv_check_init`.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_check_start(\n  handle: *mut uv_check_t,\n  cb: uv_check_cb,\n) -\u003e c_int {\n  unsafe {\n    if (*handle).flags \u0026 UV_HANDLE_ACTIVE != 0 {\n      (*handle).cb = Some(cb);\n      return 0;\n    }\n    (*handle).cb = Some(cb);\n    (*handle).flags |= UV_HANDLE_ACTIVE;\n\n    let loop_ = (*handle).loop_;\n    let inner = get_inner(loop_);\n    inner.check_handles.borrow_mut().push(handle);\n  }\n  0\n}\n\n/// Stop a check handle.\n///\n/// # Safety\n/// `handle` must have been initialized with `uv_check_init`.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_check_stop(handle: *mut uv_check_t) -\u003e c_int {\n  unsafe {\n    if (*handle).flags \u0026 UV_HANDLE_ACTIVE == 0 {\n      return 0;\n    }\n    let loop_ = (*handle).loop_;\n    let inner = get_inner(loop_);\n    inner.stop_check(handle);\n    (*handle).cb = None;\n  }\n  0\n}\n\n// ---------------------------------------------------------------------------\n// Common handle API\n// ---------------------------------------------------------------------------\n\n/// Close a handle. The `close_cb` is called asynchronously in the close phase.\n///\n/// # Safety\n/// `handle` must be a valid, initialized handle pointer.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_close(\n  handle: *mut uv_handle_t,\n  close_cb: Option\u003cuv_close_cb\u003e,\n) {\n  unsafe {\n    (*handle).flags |= UV_HANDLE_CLOSING;\n    (*handle).flags \u0026= !UV_HANDLE_ACTIVE;\n\n    let loop_ = (*handle).loop_;\n    let inner = get_inner(loop_);\n\n    // Stop the handle based on its type\n    match (*handle).r#type {\n      uv_handle_type::UV_TIMER =\u003e {\n        inner.stop_timer(handle as *mut uv_timer_t);\n      }\n      uv_handle_type::UV_IDLE =\u003e {\n        inner.stop_idle(handle as *mut uv_idle_t);\n      }\n      uv_handle_type::UV_PREPARE =\u003e {\n        inner.stop_prepare(handle as *mut uv_prepare_t);\n      }\n      uv_handle_type::UV_CHECK =\u003e {\n        inner.stop_check(handle as *mut uv_check_t);\n      }\n      _ =\u003e {}\n    }\n\n    // Queue close callback for the close phase\n    inner\n      .closing_handles\n      .borrow_mut()\n      .push_back((handle, close_cb));\n  }\n}\n\n/// Reference a handle, preventing the event loop from exiting.\n///\n/// # Safety\n/// `handle` must be a valid handle pointer.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_ref(handle: *mut uv_handle_t) {\n  unsafe {\n    (*handle).flags |= UV_HANDLE_REF;\n  }\n}\n\n/// Un-reference a handle, allowing the event loop to exit even if active.\n///\n/// # Safety\n/// `handle` must be a valid handle pointer.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_unref(handle: *mut uv_handle_t) {\n  unsafe {\n    (*handle).flags \u0026= !UV_HANDLE_REF;\n  }\n}\n\n/// Check if a handle is active.\n///\n/// # Safety\n/// `handle` must be a valid handle pointer.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_is_active(handle: *const uv_handle_t) -\u003e c_int {\n  unsafe {\n    if (*handle).flags \u0026 UV_HANDLE_ACTIVE != 0 {\n      1\n    } else {\n      0\n    }\n  }\n}\n\n/// Check if a handle is closing or closed.\n///\n/// # Safety\n/// `handle` must be a valid handle pointer.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_is_closing(handle: *const uv_handle_t) -\u003e c_int {\n  unsafe {\n    if (*handle).flags \u0026 UV_HANDLE_CLOSING != 0 {\n      1\n    } else {\n      0\n    }\n  }\n}\n\n/// Run the event loop.\n///\n/// For `UV_RUN_DEFAULT`, loops until no alive handles remain or `uv_stop`\n/// is called. For `UV_RUN_ONCE`, runs a single tick. For `UV_RUN_NOWAIT`,\n/// runs a single tick without blocking.\n///\n/// When integrated with `JsRuntime`, the real event loop is driven by\n/// `poll_event_loop`. This function is useful for C-only consumers or testing.\n///\n/// # Safety\n/// `loop_` must be a valid, initialized loop pointer.\n#[unsafe(no_mangle)]\npub unsafe extern \"C\" fn uv_run(\n  loop_: *mut uv_loop_t,\n  mode: uv_run_mode,\n) -\u003e c_int {\n  unsafe {\n    let inner = get_inner(loop_);\n    (*loop_).stop_flag.set(false);\n\n    match mode {\n      uv_run_mode::UV_RUN_DEFAULT =\u003e {\n        while inner.has_alive_handles() \u0026\u0026 !(*loop_).stop_flag.get() {\n          // Sleep until next timer if no immediate work\n          if inner.idle_handles.borrow().is_empty()\n            \u0026\u0026 inner.closing_handles.borrow().is_empty()\n          {\n            if let Some(deadline) = inner.next_timer_deadline_ms() {\n              let now = inner.now_ms();\n              if deadline \u003e now {\n                std::thread::sleep(Duration::from_millis(deadline - now));\n              }\n            }\n          }\n          inner.tick();\n        }\n        if inner.has_alive_handles() {\n          1\n        } else {\n          0\n        }\n      }\n      uv_run_mode::UV_RUN_ONCE =\u003e {\n        // Sleep until next timer deadline\n        if let Some(deadline) = inner.next_timer_deadline_ms() {\n          let now = inner.now_ms();\n          if deadline \u003e now\n            \u0026\u0026 inner.idle_handles.borrow().is_empty()\n            \u0026\u0026 inner.closing_handles.borrow().is_empty()\n          {\n            std::thread::sleep(Duration::from_millis(deadline - now));\n          }\n        }\n        inner.tick();\n        if inner.has_alive_handles() {\n          1\n        } else {\n          0\n        }\n      }\n      uv_run_mode::UV_RUN_NOWAIT =\u003e {\n        inner.tick();\n        if inner.has_alive_handles() {\n          1\n        } else {\n          0\n        }\n      }\n    }\n  }\n}\n\n// ---------------------------------------------------------------------------\n// Tests\n// ---------------------------------------------------------------------------\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n  use std::mem::MaybeUninit;\n  use std::sync::atomic::{AtomicU32, AtomicBool, Ordering};\n\n  /// Helper: allocate and init a loop on the heap.\n  unsafe fn make_loop() -\u003e *mut uv_loop_t {\n    let loop_ = Box::into_raw(Box::new(MaybeUninit::\u003cuv_loop_t\u003e::uninit()))\n      as *mut uv_loop_t;\n    unsafe { uv_loop_init(loop_) };\n    loop_\n  }\n\n  /// Helper: destroy a loop created with `make_loop`.\n  unsafe fn destroy_loop(loop_: *mut uv_loop_t) {\n    unsafe {\n      uv_loop_close(loop_);\n      drop(Box::from_raw(loop_));\n    }\n  }\n\n  // 1. Loop init/close lifecycle\n  #[test]\n  fn test_loop_init_close() {\n    unsafe {\n      let loop_ = make_loop();\n      assert!(!(*loop_).internal.is_null());\n      uv_loop_close(loop_);\n      assert!((*loop_).internal.is_null());\n      drop(Box::from_raw(loop_));\n    }\n  }\n\n  // 2. Timer fires after timeout via uv_run(ONCE)\n  #[test]\n  fn test_timer_fires() {\n    unsafe {\n      let loop_ = make_loop();\n      let mut timer = MaybeUninit::\u003cuv_timer_t\u003e::uninit();\n      let timer_ptr = timer.as_mut_ptr();\n      uv_timer_init(loop_, timer_ptr);\n\n      static FIRED: AtomicBool = AtomicBool::new(false);\n      unsafe extern \"C\" fn timer_cb(_handle: *mut uv_timer_t) {\n        FIRED.store(true, Ordering::Relaxed);\n      }\n\n      uv_timer_start(timer_ptr, timer_cb, 10, 0);\n      assert_eq!((*timer_ptr).flags \u0026 UV_HANDLE_ACTIVE, UV_HANDLE_ACTIVE);\n\n      // Run once — should sleep and fire\n      uv_run(loop_, uv_run_mode::UV_RUN_ONCE);\n      assert!(FIRED.load(Ordering::Relaxed));\n      // One-shot timer should be inactive\n      assert_eq!((*timer_ptr).flags \u0026 UV_HANDLE_ACTIVE, 0);\n\n      destroy_loop(loop_);\n    }\n  }\n\n  // 3. Repeat timer fires multiple times\n  #[test]\n  fn test_repeat_timer() {\n    unsafe {\n      let loop_ = make_loop();\n      let mut timer = MaybeUninit::\u003cuv_timer_t\u003e::uninit();\n      let timer_ptr = timer.as_mut_ptr();\n      uv_timer_init(loop_, timer_ptr);\n\n      static COUNT: AtomicU32 = AtomicU32::new(0);\n      unsafe extern \"C\" fn timer_cb(handle: *mut uv_timer_t) {\n        let c = COUNT.fetch_add(1, Ordering::Relaxed) + 1;\n        if c \u003e= 3 {\n          unsafe { uv_timer_stop(handle) };\n        }\n      }\n\n      COUNT.store(0, Ordering::Relaxed);\n      uv_timer_start(timer_ptr, timer_cb, 5, 5);\n\n      uv_run(loop_, uv_run_mode::UV_RUN_DEFAULT);\n      assert_eq!(COUNT.load(Ordering::Relaxed), 3);\n\n      destroy_loop(loop_);\n    }\n  }\n\n  // 4. Idle callbacks fire every iteration\n  #[test]\n  fn test_idle_fires() {\n    unsafe {\n      let loop_ = make_loop();\n      let mut idle = MaybeUninit::\u003cuv_idle_t\u003e::uninit();\n      let idle_ptr = idle.as_mut_ptr();\n      uv_idle_init(loop_, idle_ptr);\n\n      static IDLE_COUNT: AtomicU32 = AtomicU32::new(0);\n      unsafe extern \"C\" fn idle_cb(handle: *mut uv_idle_t) {\n        let c = IDLE_COUNT.fetch_add(1, Ordering::Relaxed) + 1;\n        if c \u003e= 5 {\n          unsafe { uv_idle_stop(handle) };\n        }\n      }\n\n      IDLE_COUNT.store(0, Ordering::Relaxed);\n      uv_idle_start(idle_ptr, idle_cb);\n\n      uv_run(loop_, uv_run_mode::UV_RUN_DEFAULT);\n      assert_eq!(IDLE_COUNT.load(Ordering::Relaxed), 5);\n\n      destroy_loop(loop_);\n    }\n  }\n\n  // 5. Prepare/check fire in correct order\n  #[test]\n  fn test_prepare_check_order() {\n    unsafe {\n      let loop_ = make_loop();\n\n      let mut prepare = MaybeUninit::\u003cuv_prepare_t\u003e::uninit();\n      let prepare_ptr = prepare.as_mut_ptr();\n      uv_prepare_init(loop_, prepare_ptr);\n\n      let mut check = MaybeUninit::\u003cuv_check_t\u003e::uninit();\n      let check_ptr = check.as_mut_ptr();\n      uv_check_init(loop_, check_ptr);\n\n      // Use a Vec\u003c\u0026str\u003e stored in loop data to track order\n      let mut order: Vec\u003c\u0026str\u003e = Vec::new();\n      let order_ptr = \u0026mut order as *mut Vec\u003c\u0026str\u003e as *mut c_void;\n      (*loop_).data = order_ptr;\n\n      unsafe extern \"C\" fn prepare_cb(handle: *mut uv_prepare_t) {\n        unsafe {\n          let loop_ = (*handle).loop_;\n          let order =\n            \u0026mut *((*loop_).data as *mut Vec\u003c\u0026str\u003e);\n          order.push(\"prepare\");\n          uv_prepare_stop(handle);\n        }\n      }\n\n      unsafe extern \"C\" fn check_cb(handle: *mut uv_check_t) {\n        unsafe {\n          let loop_ = (*handle).loop_;\n          let order =\n            \u0026mut *((*loop_).data as *mut Vec\u003c\u0026str\u003e);\n          order.push(\"check\");\n          uv_check_stop(handle);\n        }\n      }\n\n      uv_prepare_start(prepare_ptr, prepare_cb);\n      uv_check_start(check_ptr, check_cb);\n\n      uv_run(loop_, uv_run_mode::UV_RUN_ONCE);\n\n      assert_eq!(order, vec![\"prepare\", \"check\"]);\n\n      destroy_loop(loop_);\n    }\n  }\n\n  // 6. uv_close queues callback to close phase\n  #[test]\n  fn test_close_callback() {\n    unsafe {\n      let loop_ = make_loop();\n      let mut timer = MaybeUninit::\u003cuv_timer_t\u003e::uninit();\n      let timer_ptr = timer.as_mut_ptr();\n      uv_timer_init(loop_, timer_ptr);\n\n      static CLOSE_CALLED: AtomicBool = AtomicBool::new(false);\n      unsafe extern \"C\" fn close_cb(_handle: *mut uv_handle_t) {\n        CLOSE_CALLED.store(true, Ordering::Relaxed);\n      }\n\n      CLOSE_CALLED.store(false, Ordering::Relaxed);\n\n      // Start and immediately close\n      unsafe extern \"C\" fn noop_cb(_handle: *mut uv_timer_t) {}\n      uv_timer_start(timer_ptr, noop_cb, 1000, 0);\n      uv_close(timer_ptr as *mut uv_handle_t, Some(close_cb));\n\n      assert_eq!(\n        (*timer_ptr).flags \u0026 UV_HANDLE_CLOSING,\n        UV_HANDLE_CLOSING\n      );\n      // Close callback should not have been called yet\n      assert!(!CLOSE_CALLED.load(Ordering::Relaxed));\n\n      // Run once to process close callbacks\n      uv_run(loop_, uv_run_mode::UV_RUN_ONCE);\n      assert!(CLOSE_CALLED.load(Ordering::Relaxed));\n\n      destroy_loop(loop_);\n    }\n  }\n\n  // 7. uv_unref prevents handle from keeping loop alive\n  #[test]\n  fn test_unref_exits_loop() {\n    unsafe {\n      let loop_ = make_loop();\n      let mut timer = MaybeUninit::\u003cuv_timer_t\u003e::uninit();\n      let timer_ptr = timer.as_mut_ptr();\n      uv_timer_init(loop_, timer_ptr);\n\n      unsafe extern \"C\" fn noop_cb(_handle: *mut uv_timer_t) {}\n      uv_timer_start(timer_ptr, noop_cb, 60000, 0);\n\n      // Unref the timer — loop should exit immediately\n      uv_unref(timer_ptr as *mut uv_handle_t);\n\n      let result = uv_run(loop_, uv_run_mode::UV_RUN_NOWAIT);\n      assert_eq!(result, 0); // 0 = no alive handles\n\n      // Clean up\n      uv_timer_stop(timer_ptr);\n      destroy_loop(loop_);\n    }\n  }\n\n  // 8. uv_stop breaks DEFAULT loop\n  #[test]\n  fn test_stop_breaks_loop() {\n    unsafe {\n      let loop_ = make_loop();\n      let mut idle = MaybeUninit::\u003cuv_idle_t\u003e::uninit();\n      let idle_ptr = idle.as_mut_ptr();\n      uv_idle_init(loop_, idle_ptr);\n\n      static STOP_COUNT: AtomicU32 = AtomicU32::new(0);\n\n      // Store loop pointer in handle data for the callback\n      (*idle_ptr).data = loop_ as *mut c_void;\n\n      unsafe extern \"C\" fn idle_stop_cb(handle: *mut uv_idle_t) {\n        let c = STOP_COUNT.fetch_add(1, Ordering::Relaxed) + 1;\n        if c \u003e= 3 {\n          let loop_ = unsafe { (*handle).data as *mut uv_loop_t };\n          unsafe { uv_stop(loop_) };\n        }\n      }\n\n      STOP_COUNT.store(0, Ordering::Relaxed);\n      uv_idle_start(idle_ptr, idle_stop_cb);\n\n      uv_run(loop_, uv_run_mode::UV_RUN_DEFAULT);\n\n      // Should have stopped after 3 iterations\n      assert_eq!(STOP_COUNT.load(Ordering::Relaxed), 3);\n\n      uv_idle_stop(idle_ptr);\n      destroy_loop(loop_);\n    }\n  }\n\n  // 9. timer_again re-arms a repeat timer\n  #[test]\n  fn test_timer_again() {\n    unsafe {\n      let loop_ = make_loop();\n      let mut timer = MaybeUninit::\u003cuv_timer_t\u003e::uninit();\n      let timer_ptr = timer.as_mut_ptr();\n      uv_timer_init(loop_, timer_ptr);\n\n      // timer_again with repeat=0 should fail\n      assert_eq!(uv_timer_again(timer_ptr), -22);\n\n      static AGAIN_FIRED: AtomicBool = AtomicBool::new(false);\n      unsafe extern \"C\" fn timer_cb(handle: *mut uv_timer_t) {\n        AGAIN_FIRED.store(true, Ordering::Relaxed);\n        unsafe { uv_timer_stop(handle) };\n      }\n\n      AGAIN_FIRED.store(false, Ordering::Relaxed);\n      // Start timer first to set the callback, then use timer_again to restart\n      uv_timer_start(timer_ptr, timer_cb, 1000, 10);\n      uv_timer_stop(timer_ptr);\n      uv_timer_again(timer_ptr);\n\n      uv_run(loop_, uv_run_mode::UV_RUN_DEFAULT);\n      assert!(AGAIN_FIRED.load(Ordering::Relaxed));\n\n      destroy_loop(loop_);\n    }\n  }\n\n  // 10. timer get/set repeat\n  #[test]\n  fn test_timer_get_set_repeat() {\n    unsafe {\n      let loop_ = make_loop();\n      let mut timer = MaybeUninit::\u003cuv_timer_t\u003e::uninit();\n      let timer_ptr = timer.as_mut_ptr();\n      uv_timer_init(loop_, timer_ptr);\n\n      assert_eq!(uv_timer_get_repeat(timer_ptr), 0);\n      uv_timer_set_repeat(timer_ptr, 42);\n      assert_eq!(uv_timer_get_repeat(timer_ptr), 42);\n\n      destroy_loop(loop_);\n    }\n  }\n}\n\n[file map]\n  type uv_handle_type: L27-33\n  type uv_run_mode: L38-42\n  type uv_loop_t: L55-62\n  type uv_handle_t: L66-71\n  type uv_timer_t: L75-87\n  type uv_idle_t: L91-97\n  type uv_prepare_t: L101-107\n  type uv_check_t: L111-117\n  type TimerKey: L136-139\n  impl UvLoopInner: L157-415\n  func new: L158-169\n  func alloc_timer_id: L171-175\n  func now_ms: L177-179\n  func has_alive_handles: L201-243\n  func next_timer_deadline_ms: L246-248\n  func stop_idle: L386-394\n  func stop_prepare: L396-404\n  func stop_check: L406-414\n  func test_loop_init_close: L1036-1044\n  func test_timer_fires: L1048-1071\n  func test_repeat_timer: L1075-1098\n  func test_idle_fires: L1102-1125\n  func test_prepare_check_order: L1129-1175\n  func test_close_callback: L1179-1211\n  func test_unref_exits_loop: L1215-1235\n  func test_stop_breaks_loop: L1239-1270\n  func test_timer_again: L1274-1301\n  func test_timer_get_set_repeat: L1305-1318\n",
      "is_error": false,
      "duration_ms": 1
    },
    {
      "tool": "read_file",
      "input": {
        "path": "core/event_loop.rs"
      },
      "output": "// Copyright 2018-2025 the Deno authors. MIT license.\n\n//! Phase-based event loop matching libuv's architecture.\n//!\n//! Each iteration of the event loop runs these phases **in order**:\n//!\n//! ```text\n//! ┌───────────────────────────────┐\n//! │         timers                │  ← Execute expired setTimeout/setInterval callbacks\n//! ├───────────────────────────────┤\n//! │     pending callbacks         │  ← I/O callbacks deferred from previous iteration\n//! ├───────────────────────────────┤\n//! │       idle / prepare          │  ← Internal hooks (op submission, GC hints)\n//! ├───────────────────────────────┤\n//! │          poll                 │  ← Poll async reactor for I/O completion, drive futures\n//! ├───────────────────────────────┤\n//! │         check                 │  ← setImmediate / queueMicrotask drain\n//! ├───────────────────────────────┤\n//! │      close callbacks          │  ← Resource cleanup callbacks\n//! ├───────────────────────────────┤\n//! │  (between iterations)         │  ← nextTick queue drain + microtask checkpoint\n//! └───────────────────────────────┘\n//! ```\n//!\n//! **Between every phase**: run microtask checkpoint (`scope.perform_microtask_checkpoint()`).\n\nuse std::collections::VecDeque;\n\n/// Phase identifiers for the event loop.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum EventLoopPhase {\n  /// Phase 1: Execute expired timer callbacks (setTimeout, setInterval).\n  Timers,\n  /// Phase 2: Execute I/O callbacks deferred from the previous iteration.\n  PendingCallbacks,\n  /// Phase 3a: Internal idle hooks.\n  Idle,\n  /// Phase 3b: Internal prepare hooks.\n  Prepare,\n  /// Phase 4: Poll the async reactor for I/O completion and drive futures.\n  Poll,\n  /// Phase 5: Execute setImmediate callbacks.\n  Check,\n  /// Phase 6: Execute close callbacks (resource cleanup).\n  CloseCallbacks,\n}\n\nimpl EventLoopPhase {\n  /// Returns all phases in execution order.\n  pub const fn all() -\u003e \u0026'static [EventLoopPhase] {\n    \u0026[\n      EventLoopPhase::Timers,\n      EventLoopPhase::PendingCallbacks,\n      EventLoopPhase::Idle,\n      EventLoopPhase::Prepare,\n      EventLoopPhase::Poll,\n      EventLoopPhase::Check,\n      EventLoopPhase::CloseCallbacks,\n    ]\n  }\n}\n\n/// Callback type for phase observers (idle, prepare, check).\npub(crate) type PhaseCallback = Box\u003cdyn FnMut()\u003e;\n\n/// Pending callback deferred from a previous iteration (I/O result).\n#[allow(dead_code)]\npub(crate) struct PendingCallback {\n  pub callback: Box\u003cdyn FnOnce()\u003e,\n}\n\n/// Close callback for resource cleanup.\npub(crate) struct CloseCallback {\n  pub callback: Box\u003cdyn FnOnce()\u003e,\n}\n\n/// Phase-specific state for the event loop.\n#[allow(dead_code)]\npub(crate) struct EventLoopPhases {\n  /// Phase 2: Callbacks deferred from previous iteration.\n  pub pending_callbacks: VecDeque\u003cPendingCallback\u003e,\n  /// Phase 6: Close callbacks.\n  pub close_callbacks: VecDeque\u003cCloseCallback\u003e,\n  /// Phase 3a: Idle observers.\n  pub idle_observers: Vec\u003cPhaseCallback\u003e,\n  /// Phase 3b: Prepare observers.\n  pub prepare_observers: Vec\u003cPhaseCallback\u003e,\n  /// Phase 5: Check observers (setImmediate lives here).\n  pub check_observers: Vec\u003cPhaseCallback\u003e,\n}\n\nimpl Default for EventLoopPhases {\n  fn default() -\u003e Self {\n    Self {\n      pending_callbacks: VecDeque::new(),\n      close_callbacks: VecDeque::new(),\n      idle_observers: Vec::new(),\n      prepare_observers: Vec::new(),\n      check_observers: Vec::new(),\n    }\n  }\n}\n\nimpl EventLoopPhases {\n  /// Run all idle phase observers.\n  #[allow(dead_code)]\n  pub fn run_idle(\u0026mut self) {\n    for observer in self.idle_observers.iter_mut() {\n      observer();\n    }\n  }\n\n  /// Run all prepare phase observers.\n  #[allow(dead_code)]\n  pub fn run_prepare(\u0026mut self) {\n    for observer in self.prepare_observers.iter_mut() {\n      observer();\n    }\n  }\n\n  /// Run all check phase observers.\n  #[allow(dead_code)]\n  pub fn run_check(\u0026mut self) {\n    for observer in self.check_observers.iter_mut() {\n      observer();\n    }\n  }\n\n  /// Drain and run all pending callbacks.\n  #[allow(dead_code)]\n  pub fn run_pending_callbacks(\u0026mut self) {\n    while let Some(cb) = self.pending_callbacks.pop_front() {\n      (cb.callback)();\n    }\n  }\n\n  /// Drain and run all close callbacks.\n  pub fn run_close_callbacks(\u0026mut self) {\n    while let Some(cb) = self.close_callbacks.pop_front() {\n      (cb.callback)();\n    }\n  }\n\n  /// Returns true if there is any pending work in the phase queues.\n  #[allow(dead_code)]\n  pub fn has_pending_work(\u0026self) -\u003e bool {\n    !self.pending_callbacks.is_empty()\n      || !self.close_callbacks.is_empty()\n      || !self.idle_observers.is_empty()\n      || !self.prepare_observers.is_empty()\n      || !self.check_observers.is_empty()\n  }\n}\n\n/// Run mode for the event loop, matching libuv's `uv_run_mode`.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n#[repr(C)]\npub enum RunMode {\n  /// Run the event loop until there are no more active handles/requests.\n  Default = 0,\n  /// Run a single iteration of the event loop.\n  Once = 1,\n  /// Run a single iteration without blocking for I/O.\n  NoWait = 2,\n}\n\n[file map]\n  type EventLoopPhase: L31-46\n  impl EventLoopPhase: L48-61\n  impl Default: L92-102\n  func default: L93-101\n  impl EventLoopPhases: L104-153\n  func run_idle: L107-111\n  func run_prepare: L115-119\n  func run_check: L123-127\n  func run_pending_callbacks: L131-135\n  func run_close_callbacks: L138-142\n  func has_pending_work: L146-152\n  type RunMode: L158-165\n",
      "is_error": false,
      "duration_ms": 0
    },
    {
      "tool": "read_file",
      "input": {
        "path": "core/reactor.rs"
      },
      "output": "// Copyright 2018-2025 the Deno authors. MIT license.\n\nuse std::future::Future;\nuse std::ops::Add;\nuse std::pin::Pin;\nuse std::task::Context;\nuse std::task::Poll;\nuse std::time::Duration;\n\n/// Abstraction over the async I/O reactor (tokio, mio, io_uring, custom).\n/// This is the only seam between deno_core and the underlying async runtime.\npub trait Reactor: 'static {\n  type Timer: ReactorTimer;\n  type Instant: ReactorInstant;\n\n  /// Create a new one-shot timer that fires at the given instant.\n  fn timer(\u0026self, deadline: Self::Instant) -\u003e Self::Timer;\n\n  /// Get the current instant.\n  fn now(\u0026self) -\u003e Self::Instant;\n\n  /// Poll the reactor for I/O readiness. This is called during the \"poll\" phase.\n  /// Drives the underlying event source (epoll/kqueue/iocp).\n  /// `timeout` = None means block indefinitely, Some(Duration::ZERO) means non-blocking.\n  fn poll(\u0026self, cx: \u0026mut Context, timeout: Option\u003cDuration\u003e) -\u003e Poll\u003c()\u003e;\n\n  /// Spawn a future onto the reactor's executor (if it has one).\n  /// Returns a handle that can be polled for the result.\n  fn spawn(\n    \u0026self,\n    fut: Pin\u003cBox\u003cdyn Future\u003cOutput = ()\u003e + 'static\u003e\u003e,\n  ) -\u003e Pin\u003cBox\u003cdyn Future\u003cOutput = ()\u003e\u003e\u003e;\n}\n\n/// A timer future that can be reset to fire at a different deadline.\npub trait ReactorTimer: Future\u003cOutput = ()\u003e + Unpin {\n  fn reset(\u0026mut self, deadline: impl Into\u003cSelf::Instant\u003e)\n  where\n    Self: Sized;\n\n  type Instant: ReactorInstant;\n\n  /// The deadline this timer is set to fire at.\n  fn deadline(\u0026self) -\u003e Self::Instant;\n}\n\n/// An instant in time, used for timer deadlines.\npub trait ReactorInstant:\n  Copy + Ord + Add\u003cDuration, Output = Self\u003e + Send + Sync + 'static\n{\n  fn now() -\u003e Self;\n  fn elapsed(\u0026self) -\u003e Duration;\n  fn checked_add(\u0026self, duration: Duration) -\u003e Option\u003cSelf\u003e;\n}\n\n/// The default reactor type, selected by feature flags.\n/// When `reactor-tokio` is enabled, this is `TokioReactor`.\n#[cfg(feature = \"reactor-tokio\")]\npub type DefaultReactor = crate::reactor_tokio::TokioReactor;\n\n[file map]\n  type Reactor: L12-33\n  func timer: L17\n  func now: L20\n  func poll: L25\n  func spawn: L29\n  type ReactorTimer: L36-45\n  func reset: L37\n  func deadline: L44\n  type ReactorInstant: L48-54\n  func now: L51\n  func elapsed: L52\n  func checked_add: L53\n",
      "is_error": false,
      "duration_ms": 0
    },
    {
      "tool": "read_file",
      "input": {
        "path": "core/reactor_tokio.rs"
      },
      "output": "// Copyright 2018-2025 the Deno authors. MIT license.\n\nuse crate::reactor::Reactor;\nuse crate::reactor::ReactorInstant;\nuse crate::reactor::ReactorTimer;\nuse std::future::Future;\nuse std::pin::Pin;\nuse std::task::Context;\nuse std::task::Poll;\nuse std::time::Duration;\nuse tokio::time::Instant;\nuse tokio::time::Sleep;\n\n/// Default reactor implementation backed by tokio.\n#[derive(Default)]\npub struct TokioReactor;\n\nimpl Reactor for TokioReactor {\n  type Timer = TokioTimer;\n  type Instant = Instant;\n\n  fn timer(\u0026self, deadline: Self::Instant) -\u003e Self::Timer {\n    TokioTimer {\n      sleep: Box::pin(tokio::time::sleep_until(deadline)),\n    }\n  }\n\n  fn now(\u0026self) -\u003e Self::Instant {\n    Instant::now()\n  }\n\n  fn poll(\u0026self, cx: \u0026mut Context, _timeout: Option\u003cDuration\u003e) -\u003e Poll\u003c()\u003e {\n    // Tokio's reactor is driven implicitly by the runtime,\n    // so we just yield back.\n    cx.waker().wake_by_ref();\n    Poll::Pending\n  }\n\n  fn spawn(\n    \u0026self,\n    fut: Pin\u003cBox\u003cdyn Future\u003cOutput = ()\u003e + 'static\u003e\u003e,\n  ) -\u003e Pin\u003cBox\u003cdyn Future\u003cOutput = ()\u003e\u003e\u003e {\n    let handle = deno_unsync::spawn(fut);\n    Box::pin(async move {\n      let _ = handle.await;\n    })\n  }\n}\n\n/// A timer backed by tokio's [`Sleep`].\npub struct TokioTimer {\n  sleep: Pin\u003cBox\u003cSleep\u003e\u003e,\n}\n\nimpl Future for TokioTimer {\n  type Output = ();\n\n  fn poll(mut self: Pin\u003c\u0026mut Self\u003e, cx: \u0026mut Context\u003c'_\u003e) -\u003e Poll\u003c()\u003e {\n    self.sleep.as_mut().poll(cx)\n  }\n}\n\nimpl ReactorTimer for TokioTimer {\n  type Instant = Instant;\n\n  fn reset(\u0026mut self, deadline: impl Into\u003cInstant\u003e) {\n    self.sleep.as_mut().reset(deadline.into());\n  }\n\n  fn deadline(\u0026self) -\u003e Instant {\n    self.sleep.deadline()\n  }\n}\n\nimpl ReactorInstant for Instant {\n  fn now() -\u003e Self {\n    Instant::now()\n  }\n\n  fn elapsed(\u0026self) -\u003e Duration {\n    Instant::elapsed(self)\n  }\n\n  fn checked_add(\u0026self, duration: Duration) -\u003e Option\u003cSelf\u003e {\n    Instant::checked_add(self, duration)\n  }\n}\n\n[file map]\n  type TokioReactor: L16-48\n  impl Reactor: L18-48\n  func timer: L22-26\n  func now: L28-30\n  func poll: L32-37\n  func spawn: L39-47\n  type TokioTimer: L51-53\n  impl Future: L55-61\n  func poll: L58-60\n  impl ReactorTimer: L63-73\n  func reset: L66-68\n  func deadline: L70-72\n  impl ReactorInstant: L75-87\n  func now: L76-78\n  func elapsed: L80-82\n  func checked_add: L84-86\n",
      "is_error": false,
      "duration_ms": 0
    },
    {
      "tool": "read_file",
      "input": {
        "path": "core/lib.rs"
      },
      "output": "// Copyright 2018-2025 the Deno authors. MIT license.\n\n#![deny(clippy::print_stderr)]\n#![deny(clippy::print_stdout)]\n#![deny(clippy::unused_async)]\n#![deny(clippy::unnecessary_wraps)]\n\npub mod arena;\nmod async_cancel;\nmod async_cell;\npub mod convert;\npub mod cppgc;\npub mod event_loop;\npub mod error;\nmod extension_set;\nmod extensions;\nmod external;\nmod fast_string;\nmod flags;\nmod gotham_state;\nmod inspector;\nmod io;\nmod module_specifier;\nmod modules;\nmod ops;\nmod ops_builtin;\nmod ops_builtin_types;\nmod ops_builtin_v8;\nmod ops_metrics;\npub mod reactor;\n#[cfg(feature = \"reactor-tokio\")]\npub mod reactor_tokio;\nmod runtime;\nmod source_map;\nmod tasks;\n#[allow(non_camel_case_types, non_upper_case_globals, clippy::missing_safety_doc)]\npub mod uv_compat;\nmod web_timeout;\npub mod webidl;\n\n// Re-exports\npub use anyhow;\npub use deno_ops::FromV8;\npub use deno_ops::ToV8;\npub use deno_ops::WebIDL;\npub use deno_ops::op2;\npub use deno_unsync as unsync;\npub use futures;\npub use parking_lot;\npub use serde;\npub use serde_json;\npub use serde_v8;\npub use serde_v8::ByteString;\npub use serde_v8::DetachedBuffer;\npub use serde_v8::JsBuffer;\npub use serde_v8::StringOrBuffer;\npub use serde_v8::ToJsBuffer;\npub use serde_v8::U16String;\npub use sourcemap;\npub use thiserror;\npub use url;\npub use v8;\n\npub use crate::async_cancel::CancelFuture;\npub use crate::async_cancel::CancelHandle;\npub use crate::async_cancel::CancelTryFuture;\npub use crate::async_cancel::Cancelable;\npub use crate::async_cancel::Canceled;\npub use crate::async_cancel::TryCancelable;\npub use crate::async_cell::AsyncMut;\npub use crate::async_cell::AsyncMutFuture;\npub use crate::async_cell::AsyncRef;\npub use crate::async_cell::AsyncRefCell;\npub use crate::async_cell::AsyncRefFuture;\npub use crate::async_cell::RcLike;\npub use crate::async_cell::RcRef;\npub use crate::convert::FromV8;\npub use crate::convert::FromV8Scopeless;\npub use crate::convert::ToV8;\npub use crate::cppgc::GarbageCollected;\npub use crate::extensions::AccessorType;\npub use crate::extensions::Extension;\npub use crate::extensions::ExtensionArguments;\npub use crate::extensions::ExtensionFileSource;\npub use crate::extensions::ExtensionFileSourceCode;\npub use crate::extensions::Op;\npub use crate::extensions::OpDecl;\npub use crate::extensions::OpMiddlewareFn;\npub use crate::external::ExternalDefinition;\npub use crate::external::ExternalPointer;\npub use crate::external::Externalizable;\npub use crate::fast_string::FastStaticString;\npub use crate::fast_string::FastString;\npub use crate::fast_string::FastStringV8AllocationError;\npub use crate::flags::v8_set_flags;\npub use crate::inspector::InspectorMsg;\npub use crate::inspector::InspectorMsgKind;\npub use crate::inspector::InspectorSessionChannels;\npub use crate::inspector::InspectorSessionKind;\npub use crate::inspector::InspectorSessionProxy;\npub use crate::inspector::InspectorSessionSend;\npub use crate::inspector::JsRuntimeInspector;\npub use crate::inspector::LocalInspectorSession;\npub use crate::inspector::SessionContainer;\npub use crate::inspector::create_worker_inspector_session_pair;\npub use crate::io::AsyncResult;\npub use crate::io::BufMutView;\npub use crate::io::BufView;\npub use crate::io::Resource;\npub use crate::io::ResourceHandle;\npub use crate::io::ResourceHandleFd;\npub use crate::io::ResourceHandleSocket;\npub use crate::io::ResourceId;\npub use crate::io::ResourceTable;\npub use crate::io::TransferredResource;\npub use crate::io::WriteOutcome;\npub use crate::module_specifier::ModuleResolutionError;\npub use crate::module_specifier::ModuleSpecifier;\npub use crate::module_specifier::resolve_import;\npub use crate::module_specifier::resolve_url;\npub use crate::modules::CustomModuleEvaluationKind;\npub use crate::modules::ExtCodeCache;\npub use crate::modules::FsModuleLoader;\npub use crate::modules::ModuleCodeBytes;\npub use crate::modules::ModuleCodeString;\npub use crate::modules::ModuleId;\npub use crate::modules::ModuleLoadOptions;\npub use crate::modules::ModuleLoadReferrer;\npub use crate::modules::ModuleLoadResponse;\npub use crate::modules::ModuleLoader;\npub use crate::modules::ModuleName;\npub use crate::modules::ModuleSource;\npub use crate::modules::ModuleSourceCode;\npub use crate::modules::ModuleSourceFuture;\npub use crate::modules::ModuleType;\npub use crate::modules::NoopModuleLoader;\npub use crate::modules::RequestedModuleType;\npub use crate::modules::ResolutionKind;\npub use crate::modules::SourceCodeCacheInfo;\npub use crate::modules::StaticModuleLoader;\npub use crate::modules::ValidateImportAttributesCb;\npub use crate::ops::ExternalOpsTracker;\npub use crate::ops::OpId;\npub use crate::ops::OpMetadata;\npub use crate::ops::OpStackTraceCallback;\npub use crate::ops::OpState;\npub use crate::ops::PromiseId;\npub use crate::ops_builtin::op_close;\npub use crate::ops_builtin::op_print;\npub use crate::ops_builtin::op_resources;\npub use crate::ops_builtin::op_void_async;\npub use crate::ops_builtin::op_void_sync;\npub use crate::ops_metrics::OpMetricsEvent;\npub use crate::ops_metrics::OpMetricsFactoryFn;\npub use crate::ops_metrics::OpMetricsFn;\npub use crate::ops_metrics::OpMetricsSource;\npub use crate::ops_metrics::OpMetricsSummary;\npub use crate::ops_metrics::OpMetricsSummaryTracker;\npub use crate::ops_metrics::merge_op_metrics;\npub use crate::runtime::CONTEXT_STATE_SLOT_INDEX;\npub use crate::runtime::CompiledWasmModuleStore;\npub use crate::runtime::ContextState;\npub use crate::runtime::CreateRealmOptions;\npub use crate::runtime::CrossIsolateStore;\npub use crate::runtime::JsRuntime;\npub use crate::runtime::JsRuntimeForSnapshot;\npub use crate::runtime::MODULE_MAP_SLOT_INDEX;\npub use crate::runtime::PollEventLoopOptions;\npub use crate::runtime::RuntimeOptions;\npub use crate::runtime::SharedArrayBufferStore;\npub use crate::runtime::V8_WRAPPER_OBJECT_INDEX;\npub use crate::runtime::V8_WRAPPER_TYPE_INDEX;\npub use crate::runtime::stats;\n\npub use crate::source_map::SourceMapData;\npub use crate::tasks::V8CrossThreadTaskSpawner;\npub use crate::tasks::V8TaskSpawner;\npub use deno_path_util::normalize_path;\npub use deno_path_util::resolve_path;\npub use deno_path_util::resolve_url_or_path;\npub use deno_path_util::specifier_has_uri_scheme;\n\n// Ensure we can use op2 in deno_core without any hackery.\nextern crate self as deno_core;\n\n/// An internal module re-exporting functions used by the #[op] (`deno_ops`) macro\n#[doc(hidden)]\npub mod _ops {\n  pub use super::cppgc::make_cppgc_object;\n  pub use super::cppgc::make_cppgc_proto_object;\n  pub use super::cppgc::try_unwrap_cppgc_object;\n  pub use super::cppgc::try_unwrap_cppgc_proto_object;\n  pub use super::error::throw_error_js_error_class;\n  pub use super::error::throw_error_one_byte;\n  pub use super::error::throw_error_one_byte_info;\n  pub use super::extensions::Op;\n  pub use super::extensions::OpDecl;\n  pub use super::extensions::OpMethodDecl;\n  pub use super::ops::OpCtx;\n  #[cfg(debug_assertions)]\n  pub use super::ops::reentrancy_check;\n  pub use super::ops_metrics::OpMetricsEvent;\n  pub use super::ops_metrics::dispatch_metrics_async;\n  pub use super::ops_metrics::dispatch_metrics_fast;\n  pub use super::ops_metrics::dispatch_metrics_slow;\n  pub use super::runtime::V8_WRAPPER_OBJECT_INDEX;\n  pub use super::runtime::V8_WRAPPER_TYPE_INDEX;\n  pub use super::runtime::ops::*;\n  pub use super::runtime::ops_rust_to_v8::*;\n}\n\npub mod snapshot {\n  pub use crate::runtime::CreateSnapshotOptions;\n  pub use crate::runtime::CreateSnapshotOutput;\n  pub use crate::runtime::FilterFn;\n  pub use crate::runtime::create_snapshot;\n  pub use crate::runtime::get_js_files;\n}\n\n/// A helper macro that will return a call site in Rust code. Should be\n/// used when executing internal one-line scripts for JsRuntime lifecycle.\n///\n/// Returns a string in form of: \"`[ext:\u003cfilename\u003e:\u003cline\u003e:\u003ccolumn\u003e]`\"\n#[macro_export]\nmacro_rules! located_script_name {\n  () =\u003e {\n    concat!(\n      \"[ext:\",\n      ::std::file!(),\n      \":\",\n      ::std::line!(),\n      \":\",\n      ::std::column!(),\n      \"]\"\n    )\n  };\n}\n\n#[cfg(all(test, not(miri)))]\nmod tests {\n  use std::process::Command;\n  use std::process::Stdio;\n\n  #[test]\n  fn located_script_name() {\n    // Note that this test will fail if this file is moved. We don't\n    // test line locations because that's just too brittle.\n    let name = located_script_name!();\n    let expected = if cfg!(windows) {\n      \"[ext:core\\\\lib.rs:\"\n    } else {\n      \"[ext:core/lib.rs:\"\n    };\n    assert_eq!(\u0026name[..expected.len()], expected);\n  }\n\n  // If the deno command is available, we ensure the async stubs are correctly rebuilt.\n  #[test]\n  #[cfg_attr(all(target_os = \"windows\", target_arch = \"aarch64\"), ignore)]\n  fn test_rebuild_async_stubs() {\n    // Check for deno first\n    if let Err(e) = Command::new(\"deno\")\n      .arg(\"--version\")\n      .stderr(Stdio::null())\n      .stdout(Stdio::null())\n      .status()\n    {\n      #[allow(clippy::print_stderr)]\n      {\n        eprintln!(\"Ignoring test because we couldn't find deno: {e:?}\");\n      }\n    }\n    let status = Command::new(\"deno\")\n      .args([\"run\", \"-A\", \"rebuild_async_stubs.js\", \"--check\"])\n      .stderr(Stdio::null())\n      .stdout(Stdio::null())\n      .status()\n      .unwrap();\n    assert!(\n      status.success(),\n      \"Async stubs were not updated, or 'rebuild_async_stubs.js' failed for some other reason\"\n    );\n  }\n}\n\n[file map]\n  func located_script_name: L245-255\n  func test_rebuild_async_stubs: L260-283\n",
      "is_error": false,
      "duration_ms": 0
    },
    {
      "tool": "bash",
      "input": {
        "command": "rg -n \"uv_compat\" -n"
      },
      "output": "core/runtime/jsrealm.rs:28:use crate::uv_compat::UvLoopInner;\ncore/lib.rs:37:pub mod uv_compat;\n",
      "is_error": false,
      "duration_ms": 55
    },
    {
      "tool": "read_file",
      "input": {
        "path": "core/runtime.jsrealm.rs"
      },
      "output": "Error reading file: open core/runtime.jsrealm.rs: no such file or directory",
      "is_error": true,
      "duration_ms": 0
    },
    {
      "tool": "list_files",
      "input": {
        "path": "core"
      },
      "output": "00_infra.js\n00_primordials.js\n01_core.js\nCargo.toml\nREADME.md\narena/\nasync_cancel.rs\nasync_cell.rs\nbenches/\nconvert.rs\ncore.d.ts\ncppgc.rs\nerror.rs\nevent_loop.rs\nexamples/\nextension_set.rs\nextensions.rs\nexternal.rs\nfast_string.rs\nflags.rs\ngotham_state.rs\ninspector.rs\nio/\nlib.rs\nmod.js\nmodule_specifier.rs\nmodules/\nops.rs\nops_builtin.rs\nops_builtin_types.rs\nops_builtin_v8.rs\nops_metrics.rs\nreactor.rs\nreactor_tokio.rs\nrebuild_async_stubs.js\nruntime/\nsource_map.rs\ntasks.rs\nuv_compat.rs\nweb_timeout.rs\nwebidl.rs\n",
      "is_error": false,
      "duration_ms": 0
    },
    {
      "tool": "read_file",
      "input": {
        "path": "core/runtime.rs"
      },
      "output": "Error reading file: open core/runtime.rs: no such file or directory",
      "is_error": true,
      "duration_ms": 0
    },
    {
      "tool": "bash",
      "input": {
        "command": "rg -n \"UvLoopInner\" -n"
      },
      "output": "core/uv_compat.rs:130:// UvLoopInner — internal state behind uv_loop_t.internal\ncore/uv_compat.rs:142:pub(crate) struct UvLoopInner {\ncore/uv_compat.rs:157:impl UvLoopInner {\ncore/uv_compat.rs:417:/// Get the `UvLoopInner` from a `uv_loop_t` pointer.\ncore/uv_compat.rs:422:unsafe fn get_inner(loop_: *mut uv_loop_t) -\u003e \u0026'static UvLoopInner {\ncore/uv_compat.rs:423:  unsafe { \u0026*((*loop_).internal as *const UvLoopInner) }\ncore/uv_compat.rs:436:  let inner = Box::new(UvLoopInner::new());\ncore/uv_compat.rs:455:      drop(Box::from_raw(internal as *mut UvLoopInner));\ncore/runtime/jsrealm.rs:28:use crate::uv_compat::UvLoopInner;\ncore/runtime/jsrealm.rs:108:  /// Pointer to the UvLoopInner for the libuv compat layer.\ncore/runtime/jsrealm.rs:110:  pub(crate) uv_loop_inner: Cell\u003cOption\u003c*const UvLoopInner\u003e\u003e,\n",
      "is_error": false,
      "duration_ms": 44
    },
    {
      "tool": "read_file",
      "input": {
        "path": "core/runtime/jsrealm.rs"
      },
      "output": "// Copyright 2018-2025 the Deno authors. MIT license.\n\nuse super::exception_state::ExceptionState;\n#[cfg(test)]\nuse super::op_driver::OpDriver;\nuse crate::_ops::OpMethodDecl;\nuse crate::ModuleSourceCode;\nuse crate::SourceCodeCacheInfo;\nuse crate::cppgc::FunctionTemplateData;\nuse crate::error::CoreError;\nuse crate::error::CreateCodeCacheError;\nuse crate::error::JsError;\nuse crate::error::exception_to_err;\nuse crate::error::exception_to_err_result;\nuse crate::module_specifier::ModuleSpecifier;\nuse crate::modules::IntoModuleCodeString;\nuse crate::modules::IntoModuleName;\nuse crate::modules::ModuleCodeString;\nuse crate::modules::ModuleId;\nuse crate::modules::ModuleMap;\nuse crate::modules::ModuleName;\nuse crate::modules::script_origin;\nuse crate::ops::ExternalOpsTracker;\nuse crate::ops::OpCtx;\nuse crate::stats::RuntimeActivityTraces;\nuse crate::event_loop::EventLoopPhases;\nuse crate::reactor::DefaultReactor;\nuse crate::uv_compat::UvLoopInner;\nuse crate::tasks::V8TaskSpawnerFactory;\nuse crate::web_timeout::WebTimers;\nuse futures::stream::StreamExt;\nuse std::cell::Cell;\nuse std::cell::RefCell;\nuse std::collections::HashSet;\nuse std::hash::BuildHasherDefault;\nuse std::hash::Hasher;\nuse std::rc::Rc;\nuse std::sync::Arc;\n\npub const CONTEXT_STATE_SLOT_INDEX: i32 = 1;\npub const MODULE_MAP_SLOT_INDEX: i32 = 2;\n\n// Hasher used for `unrefed_ops`. Since these are rolling i32, there's no\n// need to actually hash them.\n#[derive(Default)]\npub(crate) struct IdentityHasher(u64);\n\nimpl Hasher for IdentityHasher {\n  fn write_i32(\u0026mut self, i: i32) {\n    self.0 = i as u64;\n  }\n\n  fn finish(\u0026self) -\u003e u64 {\n    self.0\n  }\n\n  fn write(\u0026mut self, _bytes: \u0026[u8]) {\n    unreachable!()\n  }\n}\n\n/// We may wish to experiment with alternative drivers in the future.\npub(crate) type OpDriverImpl = super::op_driver::FuturesUnorderedDriver;\n\npub(crate) type UnrefedOps =\n  Rc\u003cRefCell\u003cHashSet\u003ci32, BuildHasherDefault\u003cIdentityHasher\u003e\u003e\u003e\u003e;\n\n#[derive(Debug, Default)]\npub(crate) struct ImmediateInfo {\n  pub count: u32,\n  pub ref_count: u32,\n  pub has_outstanding: bool,\n}\n\npub struct ContextState {\n  pub(crate) task_spawner_factory: Arc\u003cV8TaskSpawnerFactory\u003e,\n  pub(crate) timers: WebTimers\u003c(v8::Global\u003cv8::Function\u003e, u32), DefaultReactor\u003e,\n  // Per-phase JS callbacks (replacing monolithic eventLoopTick)\n  pub(crate) js_resolve_ops_cb: RefCell\u003cOption\u003cv8::Global\u003cv8::Function\u003e\u003e\u003e,\n  pub(crate) js_drain_next_tick_and_macrotasks_cb:\n    RefCell\u003cOption\u003cv8::Global\u003cv8::Function\u003e\u003e\u003e,\n  pub(crate) js_handle_rejections_cb:\n    RefCell\u003cOption\u003cv8::Global\u003cv8::Function\u003e\u003e\u003e,\n  pub(crate) js_set_timer_depth_cb:\n    RefCell\u003cOption\u003cv8::Global\u003cv8::Function\u003e\u003e\u003e,\n  pub(crate) js_report_exception_cb:\n    RefCell\u003cOption\u003cv8::Global\u003cv8::Function\u003e\u003e\u003e,\n  pub(crate) run_immediate_callbacks_cb:\n    RefCell\u003cOption\u003cv8::Global\u003cv8::Function\u003e\u003e\u003e,\n  pub(crate) js_wasm_streaming_cb: RefCell\u003cOption\u003cv8::Global\u003cv8::Function\u003e\u003e\u003e,\n  pub(crate) wasm_instance_fn: RefCell\u003cOption\u003cv8::Global\u003cv8::Function\u003e\u003e\u003e,\n  pub(crate) unrefed_ops: UnrefedOps,\n  pub(crate) activity_traces: RuntimeActivityTraces,\n  pub(crate) pending_ops: Rc\u003cOpDriverImpl\u003e,\n  // We don't explicitly re-read this prop but need the slice to live alongside\n  // the context\n  pub(crate) op_ctxs: Box\u003c[OpCtx]\u003e,\n  pub(crate) op_method_decls: Vec\u003cOpMethodDecl\u003e,\n  pub(crate) methods_ctx_offset: usize,\n  pub(crate) isolate: Option\u003cv8::UnsafeRawIsolatePtr\u003e,\n  pub(crate) exception_state: Rc\u003cExceptionState\u003e,\n  pub(crate) has_next_tick_scheduled: Cell\u003cbool\u003e,\n  pub(crate) immediate_info: RefCell\u003cImmediateInfo\u003e,\n  pub(crate) external_ops_tracker: ExternalOpsTracker,\n  pub(crate) ext_import_meta_proto: RefCell\u003cOption\u003cv8::Global\u003cv8::Object\u003e\u003e\u003e,\n  /// Phase-specific state for the libuv-style event loop.\n  pub(crate) event_loop_phases: RefCell\u003cEventLoopPhases\u003e,\n  /// Pointer to the UvLoopInner for the libuv compat layer.\n  /// Set when a `uv_loop_t` is initialized and associated with this context.\n  pub(crate) uv_loop_inner: Cell\u003cOption\u003c*const UvLoopInner\u003e\u003e,\n}\n\nimpl ContextState {\n  pub(crate) fn new(\n    op_driver: Rc\u003cOpDriverImpl\u003e,\n    isolate_ptr: v8::UnsafeRawIsolatePtr,\n    op_ctxs: Box\u003c[OpCtx]\u003e,\n    op_method_decls: Vec\u003cOpMethodDecl\u003e,\n    methods_ctx_offset: usize,\n    external_ops_tracker: ExternalOpsTracker,\n    unrefed_ops: UnrefedOps,\n  ) -\u003e Self {\n    Self {\n      isolate: Some(isolate_ptr),\n      exception_state: Default::default(),\n      has_next_tick_scheduled: Default::default(),\n      immediate_info: Default::default(),\n      js_resolve_ops_cb: Default::default(),\n      js_drain_next_tick_and_macrotasks_cb: Default::default(),\n      js_handle_rejections_cb: Default::default(),\n      js_set_timer_depth_cb: Default::default(),\n      js_report_exception_cb: Default::default(),\n      run_immediate_callbacks_cb: Default::default(),\n      js_wasm_streaming_cb: Default::default(),\n      wasm_instance_fn: Default::default(),\n      activity_traces: Default::default(),\n      op_ctxs,\n      op_method_decls,\n      methods_ctx_offset,\n      pending_ops: op_driver,\n      task_spawner_factory: Default::default(),\n      timers: Default::default(),\n      unrefed_ops,\n      external_ops_tracker,\n      ext_import_meta_proto: Default::default(),\n      event_loop_phases: Default::default(),\n      uv_loop_inner: Cell::new(None),\n    }\n  }\n}\n\n/// A representation of a JavaScript realm tied to a [`JsRuntime`], that allows\n/// execution in the realm's context.\n///\n/// A [`JsRealm`] instance is a reference to an already existing realm, which\n/// does not hold ownership of it, so instances can be created and dropped as\n/// needed. As such, calling [`JsRealm::new`] doesn't create a new realm, and\n/// cloning a [`JsRealm`] only creates a new reference. See\n/// [`JsRuntime::create_realm`] to create new realms instead.\n///\n/// Despite [`JsRealm`] instances being references, multiple instances that\n/// point to the same realm won't overlap because every operation requires\n/// passing a mutable reference to the [`v8::Isolate`]. Therefore, no operation\n/// on two [`JsRealm`] instances tied to the same isolate can be run at the same\n/// time, regardless of whether they point to the same realm.\n///\n/// # Panics\n///\n/// Every method of [`JsRealm`] will panic if you call it with a reference to a\n/// [`v8::Isolate`] other than the one that corresponds to the current context.\n///\n/// In other words, the [`v8::Isolate`] parameter for all the related [`JsRealm`] methods\n/// must be extracted from the pre-existing [`JsRuntime`].\n///\n/// # Lifetime of the realm\n///\n/// As long as the corresponding isolate is alive, a [`JsRealm`] instance will\n/// keep the underlying V8 context alive even if it would have otherwise been\n/// garbage collected.\n#[derive(Clone)]\n#[repr(transparent)]\npub(crate) struct JsRealm(pub(crate) JsRealmInner);\n\n#[derive(Clone)]\npub(crate) struct JsRealmInner {\n  pub(crate) context_state: Rc\u003cContextState\u003e,\n  context: v8::Global\u003cv8::Context\u003e,\n  pub(crate) module_map: Rc\u003cModuleMap\u003e,\n  pub(crate) function_templates: Rc\u003cRefCell\u003cFunctionTemplateData\u003e\u003e,\n}\n\nimpl JsRealmInner {\n  pub(crate) fn new(\n    context_state: Rc\u003cContextState\u003e,\n    context: v8::Global\u003cv8::Context\u003e,\n    module_map: Rc\u003cModuleMap\u003e,\n    function_templates: Rc\u003cRefCell\u003cFunctionTemplateData\u003e\u003e,\n  ) -\u003e Self {\n    Self {\n      context_state,\n      context: context.clone(),\n      module_map,\n      function_templates,\n    }\n  }\n\n  #[inline(always)]\n  pub fn context(\u0026self) -\u003e \u0026v8::Global\u003cv8::Context\u003e {\n    \u0026self.context\n  }\n\n  #[inline(always)]\n  pub(crate) fn state(\u0026self) -\u003e Rc\u003cContextState\u003e {\n    self.context_state.clone()\n  }\n\n  #[inline(always)]\n  pub(crate) fn module_map(\u0026self) -\u003e Rc\u003cModuleMap\u003e {\n    self.module_map.clone()\n  }\n\n  #[inline(always)]\n  pub(crate) fn function_templates(\u0026self) -\u003e Rc\u003cRefCell\u003cFunctionTemplateData\u003e\u003e {\n    self.function_templates.clone()\n  }\n\n  pub fn destroy(self) {\n    let state = self.state();\n    let raw_ptr = self.state().isolate.unwrap();\n    // SAFETY: We know the isolate outlives the realm\n    let mut isolate = unsafe { v8::Isolate::from_raw_isolate_ptr(raw_ptr) };\n    v8::scope!(let scope, \u0026mut isolate);\n    // These globals will prevent snapshots from completing, take them\n    state.exception_state.prepare_to_destroy();\n    std::mem::take(\u0026mut *state.js_resolve_ops_cb.borrow_mut());\n    std::mem::take(\u0026mut *state.js_drain_next_tick_and_macrotasks_cb.borrow_mut());\n    std::mem::take(\u0026mut *state.js_handle_rejections_cb.borrow_mut());\n    std::mem::take(\u0026mut *state.js_set_timer_depth_cb.borrow_mut());\n    std::mem::take(\u0026mut *state.js_report_exception_cb.borrow_mut());\n    std::mem::take(\u0026mut *state.run_immediate_callbacks_cb.borrow_mut());\n    std::mem::take(\u0026mut *state.js_wasm_streaming_cb.borrow_mut());\n\n    {\n      let ctx = self.context().open(scope);\n      // SAFETY: Clear all embedder data\n      unsafe {\n        let ctx_state =\n          ctx.get_aligned_pointer_from_embedder_data(CONTEXT_STATE_SLOT_INDEX);\n        let _ = Rc::from_raw(ctx_state as *mut ContextState);\n\n        let module_map =\n          ctx.get_aligned_pointer_from_embedder_data(MODULE_MAP_SLOT_INDEX);\n        // Explcitly destroy data in the module map, as there might be some pending\n        // futures there and we want them dropped.\n        let map = Rc::from_raw(module_map as *mut ModuleMap);\n        map.destroy();\n\n        ctx.set_aligned_pointer_in_embedder_data(\n          CONTEXT_STATE_SLOT_INDEX,\n          std::ptr::null_mut(),\n        );\n        ctx.set_aligned_pointer_in_embedder_data(\n          MODULE_MAP_SLOT_INDEX,\n          std::ptr::null_mut(),\n        );\n      }\n      ctx.clear_all_slots();\n      // Expect that this context is dead (we only check this in debug mode)\n      // TODO(bartlomieju): This check fails for some tests, will need to fix this\n      // debug_assert_eq!(Rc::strong_count(\u0026module_map), 1, \"ModuleMap still in use.\");\n    }\n\n    // Expect that this context is dead (we only check this in debug mode)\n    // TODO(mmastrac): This check fails for some tests, will need to fix this\n    // debug_assert_eq!(Rc::strong_count(\u0026self.context), 1, \"Realm was still alive when we wanted to destroy it. Not dropped?\");\n  }\n}\n\nunsafe fn clone_rc_raw\u003cT\u003e(raw: *const T) -\u003e Rc\u003cT\u003e {\n  unsafe {\n    Rc::increment_strong_count(raw);\n    Rc::from_raw(raw)\n  }\n}\nmacro_rules! context_scope {\n  ($scope: ident, $self: expr, $isolate: expr) =\u003e {\n    v8::scope!($scope, $isolate);\n    let context = v8::Local::new($scope, $self.context());\n    let $scope = \u0026mut v8::ContextScope::new($scope, context);\n  };\n}\n\npub(crate) use context_scope;\n\nimpl JsRealm {\n  pub(crate) fn new(inner: JsRealmInner) -\u003e Self {\n    Self(inner)\n  }\n\n  #[inline(always)]\n  pub(crate) fn state_from_scope(scope: \u0026mut v8::PinScope) -\u003e Rc\u003cContextState\u003e {\n    let context = scope.get_current_context();\n    // SAFETY: slot is valid and set during realm creation\n    unsafe {\n      let rc = context\n        .get_aligned_pointer_from_embedder_data(CONTEXT_STATE_SLOT_INDEX);\n      clone_rc_raw(rc as *const ContextState)\n    }\n  }\n\n  #[inline(always)]\n  pub(crate) fn module_map_from(scope: \u0026mut v8::PinScope) -\u003e Rc\u003cModuleMap\u003e {\n    let context = scope.get_current_context();\n    // SAFETY: slot is valid and set during realm creation\n    unsafe {\n      let rc =\n        context.get_aligned_pointer_from_embedder_data(MODULE_MAP_SLOT_INDEX);\n      clone_rc_raw(rc as *const ModuleMap)\n    }\n  }\n\n  #[inline(always)]\n  pub(crate) fn exception_state_from_scope(\n    scope: \u0026mut v8::PinScope,\n  ) -\u003e Rc\u003cExceptionState\u003e {\n    Self::state_from_scope(scope).exception_state.clone()\n  }\n\n  #[cfg(test)]\n  #[inline(always)]\n  pub fn num_pending_ops(\u0026self) -\u003e usize {\n    self.0.context_state.pending_ops.len()\n  }\n\n  #[cfg(test)]\n  #[inline(always)]\n  pub fn num_unrefed_ops(\u0026self) -\u003e usize {\n    self.0.context_state.unrefed_ops.borrow().len()\n  }\n\n  #[inline(always)]\n  pub fn context(\u0026self) -\u003e \u0026v8::Global\u003cv8::Context\u003e {\n    self.0.context()\n  }\n\n  /// Executes traditional JavaScript code (traditional = not ES modules) in the\n  /// realm's context.\n  ///\n  /// For info on the [`v8::Isolate`] parameter, check [`JsRealm#panics`].\n  ///\n  /// The `name` parameter can be a filepath or any other string. E.g.:\n  ///\n  ///   - \"/some/file/path.js\"\n  ///   - \"\u003canon\u003e\"\n  ///   - \"[native code]\"\n  ///\n  /// The same `name` value can be used for multiple executions.\n  pub fn execute_script(\n    \u0026self,\n    isolate: \u0026mut v8::Isolate,\n    name: impl IntoModuleName,\n    source_code: impl IntoModuleCodeString,\n  ) -\u003e Result\u003cv8::Global\u003cv8::Value\u003e, Box\u003cJsError\u003e\u003e {\n    context_scope!(scope, self, isolate);\n\n    let source = source_code.into_module_code().v8_string(scope).unwrap();\n    let name = name.into_module_name().v8_string(scope).unwrap();\n    let origin = script_origin(scope, name, false, None);\n\n    v8::tc_scope!(let tc_scope, scope);\n\n    let script = match v8::Script::compile(tc_scope, source, Some(\u0026origin)) {\n      Some(script) =\u003e script,\n      None =\u003e {\n        let exception = tc_scope.exception().unwrap();\n        return exception_to_err_result(tc_scope, exception, false, false);\n      }\n    };\n\n    match script.run(tc_scope) {\n      Some(value) =\u003e {\n        let value_handle = v8::Global::new(tc_scope, value);\n        Ok(value_handle)\n      }\n      None =\u003e {\n        assert!(tc_scope.has_caught());\n        let exception = tc_scope.exception().unwrap();\n        exception_to_err_result(tc_scope, exception, false, false)\n      }\n    }\n  }\n\n  // TODO(nathanwhit): reduce duplication between this and `execute_script`, and\n  // try to factor out the code cache logic to share with `op_eval_context`\n  pub fn execute_script_with_cache(\n    \u0026self,\n    isolate: \u0026mut v8::Isolate,\n    name: ModuleSpecifier,\n    source_code: impl IntoModuleCodeString,\n    get_cache: \u0026dyn Fn(\n      \u0026ModuleSpecifier,\n      \u0026ModuleSourceCode,\n    ) -\u003e SourceCodeCacheInfo,\n    cache_ready: \u0026dyn Fn(ModuleSpecifier, u64, \u0026[u8]),\n  ) -\u003e Result\u003cv8::Global\u003cv8::Value\u003e, CoreError\u003e {\n    context_scope!(scope, self, isolate);\n\n    let specifier = name.clone();\n    let code = source_code.into_module_code();\n    let source = ModuleSourceCode::String(code);\n    let code_cache = get_cache(\u0026name, \u0026source);\n    let ModuleSourceCode::String(source) = source else {\n      unreachable!()\n    };\n    let name = name.into_module_name().v8_string(scope).unwrap();\n    let source = source.v8_string(scope).unwrap();\n    let origin = script_origin(scope, name, false, None);\n    v8::tc_scope!(let tc_scope, scope);\n\n    let (maybe_script, maybe_code_cache_hash) =\n      if let Some(data) = \u0026code_cache.data {\n        let mut source = v8::script_compiler::Source::new_with_cached_data(\n          source,\n          Some(\u0026origin),\n          v8::CachedData::new(data),\n        );\n        let script = v8::script_compiler::compile(\n          tc_scope,\n          \u0026mut source,\n          v8::script_compiler::CompileOptions::ConsumeCodeCache,\n          v8::script_compiler::NoCacheReason::NoReason,\n        );\n        // Check if the provided code cache is rejected by V8.\n        let rejected = match source.get_cached_data() {\n          Some(cached_data) =\u003e cached_data.rejected(),\n          _ =\u003e true,\n        };\n        let maybe_code_cache_hash = if rejected {\n          Some(code_cache.hash) // recreate the cache\n        } else {\n          None\n        };\n        (Some(script), maybe_code_cache_hash)\n      } else {\n        (None, Some(code_cache.hash))\n      };\n\n    let script = maybe_script\n      .unwrap_or_else(|| v8::Script::compile(tc_scope, source, Some(\u0026origin)));\n\n    let script = match script {\n      Some(script) =\u003e script,\n      None =\u003e {\n        let exception = tc_scope.exception().unwrap();\n        return Ok(exception_to_err_result(tc_scope, exception, false, false)?);\n      }\n    };\n\n    if let Some(code_cache_hash) = maybe_code_cache_hash {\n      let unbound_script = script.get_unbound_script(tc_scope);\n      let code_cache = unbound_script\n        .create_code_cache()\n        .ok_or_else(|| CreateCodeCacheError(specifier.clone()))?;\n      cache_ready(specifier, code_cache_hash, \u0026code_cache);\n    }\n\n    match script.run(tc_scope) {\n      Some(value) =\u003e {\n        let value_handle = v8::Global::new(tc_scope, value);\n        Ok(value_handle)\n      }\n      None =\u003e {\n        assert!(tc_scope.has_caught());\n        let exception = tc_scope.exception().unwrap();\n        Ok(exception_to_err_result(tc_scope, exception, false, false)?)\n      }\n    }\n  }\n\n  /// Returns the namespace object of a module.\n  ///\n  /// This is only available after module evaluation has completed.\n  /// This function panics if module has not been instantiated.\n  pub fn get_module_namespace(\n    \u0026self,\n    isolate: \u0026mut v8::Isolate,\n    module_id: ModuleId,\n  ) -\u003e Result\u003cv8::Global\u003cv8::Object\u003e, CoreError\u003e {\n    context_scope!(scope, self, isolate);\n    self.0.module_map().get_module_namespace(scope, module_id)\n  }\n\n  pub(crate) fn instantiate_module(\n    \u0026self,\n    scope: \u0026mut v8::PinScope,\n    id: ModuleId,\n  ) -\u003e Result\u003c(), v8::Global\u003cv8::Value\u003e\u003e {\n    self.0.module_map().instantiate_module(scope, id)\n  }\n\n  pub(crate) fn modules_idle(\u0026self) -\u003e bool {\n    self.0.module_map.dyn_module_evaluate_idle_counter.get() \u003e 1\n  }\n\n  pub(crate) fn increment_modules_idle(\u0026self) {\n    let count = \u0026self.0.module_map.dyn_module_evaluate_idle_counter;\n    count.set(count.get() + 1)\n  }\n\n  /// Asynchronously load specified module and all of its dependencies.\n  ///\n  /// The module will be marked as \"main\", and because of that\n  /// \"import.meta.main\" will return true when checked inside that module.\n  ///\n  /// User must call [`ModuleMap::mod_evaluate`] with returned `ModuleId`\n  /// manually after load is finished.\n  pub(crate) async fn load_main_es_module_from_code(\n    \u0026self,\n    isolate: \u0026mut v8::Isolate,\n    specifier: \u0026ModuleSpecifier,\n    code: Option\u003cModuleCodeString\u003e,\n  ) -\u003e Result\u003cModuleId, CoreError\u003e {\n    let module_map_rc = self.0.module_map();\n    if let Some(code) = code {\n      context_scope!(scope, self, isolate);\n      // true for main module\n      module_map_rc\n        .new_es_module(\n          scope,\n          true,\n          specifier.to_string().into(),\n          code,\n          false,\n          None,\n        )\n        .map_err(|e| e.into_error(scope, false, false))?;\n    }\n\n    let mut load =\n      ModuleMap::load_main(module_map_rc.clone(), specifier.to_string())\n        .await?;\n\n    while let Some(load_result) = load.next().await {\n      let (request, info) = load_result?;\n      context_scope!(scope, self, isolate);\n      load\n        .register_and_recurse(scope, \u0026request, info)\n        .map_err(|e| e.into_error(scope, false, false))?;\n    }\n\n    let root_id = load.root_module_id.expect(\"Root module should be loaded\");\n    context_scope!(scope, self, isolate);\n    self.instantiate_module(scope, root_id).map_err(|e| {\n      let exception = v8::Local::new(scope, e);\n      exception_to_err(scope, exception, false, false)\n    })?;\n    Ok(root_id)\n  }\n\n  /// Asynchronously load specified ES module and all of its dependencies.\n  ///\n  /// This method is meant to be used when loading some utility code that\n  /// might be later imported by the main module (ie. an entry point module).\n  ///\n  /// User must call [`ModuleMap::mod_evaluate`] with returned `ModuleId`\n  /// manually after load is finished.\n  // TODO(bartlomieju): create a separate method to execute code synchronously\n  // from a loader? Would simplify JsRuntime code and not require running in\n  // a `block_on`.\n  pub(crate) async fn load_side_es_module_from_code(\n    \u0026self,\n    isolate: \u0026mut v8::Isolate,\n    specifier: String,\n    code: Option\u003cModuleCodeString\u003e,\n  ) -\u003e Result\u003cModuleId, CoreError\u003e {\n    let module_map_rc = self.0.module_map();\n    if let Some(code) = code {\n      let specifier = specifier.to_owned();\n      context_scope!(scope, self, isolate);\n      // false for side module (not main module)\n      module_map_rc\n        .new_es_module(scope, false, specifier.into(), code, false, None)\n        .map_err(|e| e.into_error(scope, false, false))?;\n    }\n\n    let mut load = ModuleMap::load_side(\n      module_map_rc,\n      specifier,\n      crate::modules::SideModuleKind::Async,\n      None,\n    )\n    .await?;\n\n    while let Some(load_result) = load.next().await {\n      let (request, info) = load_result?;\n      context_scope!(scope, self, isolate);\n      load\n        .register_and_recurse(scope, \u0026request, info)\n        .map_err(|e| e.into_error(scope, false, false))?;\n    }\n\n    let root_id = load.root_module_id.expect(\"Root module should be loaded\");\n    context_scope!(scope, self, isolate);\n    self.instantiate_module(scope, root_id).map_err(|e| {\n      let exception = v8::Local::new(scope, e);\n      exception_to_err(scope, exception, false, false)\n    })?;\n    Ok(root_id)\n  }\n\n  /// Load and evaluate an ES module provided the specifier and source code.\n  ///\n  /// The module should not have Top-Level Await (that is, it should be\n  /// possible to evaluate it synchronously).\n  ///\n  /// It is caller's responsibility to ensure that not duplicate specifiers are\n  /// passed to this method.\n  pub(crate) fn lazy_load_es_module_with_code(\n    \u0026self,\n    isolate: \u0026mut v8::Isolate,\n    module_specifier: ModuleName,\n    code: ModuleCodeString,\n  ) -\u003e Result\u003cv8::Global\u003cv8::Value\u003e, CoreError\u003e {\n    let module_map_rc = self.0.module_map();\n    context_scope!(scope, self, isolate);\n    module_map_rc.lazy_load_es_module_with_code(\n      scope,\n      module_specifier.as_str(),\n      code,\n      None,\n    )\n  }\n}\n\n[file map]\n  impl Hasher: L48-60\n  func write_i32: L49-51\n  func finish: L53-55\n  func write: L57-59\n  type ContextState: L75-111\n  impl ContextState: L113-150\n  impl JsRealmInner: L192-277\n  func context: L208-210\n  func destroy: L227-276\n  impl JsRealm: L295-633\n  func num_pending_ops: L331-333\n  func num_unrefed_ops: L337-339\n  func context: L342-344\n  func execute_script: L358-391\n  func execute_script_with_cache: L395-478\n  func get_module_namespace: L484-491\n",
      "is_error": false,
      "duration_ms": 1
    },
    {
      "tool": "bash",
      "input": {
        "command": "rg -n \"poll_event_loop\" -n"
      },
      "output": "core/modules/tests.rs:1111:    let result = runtime.poll_event_loop(cx, Default::default());\ncore/modules/tests.rs:1172:      runtime.poll_event_loop(cx, Default::default()),\ncore/modules/tests.rs:1177:      runtime.poll_event_loop(cx, Default::default()),\ncore/modules/tests.rs:1217:    let _ = runtime.poll_event_loop(cx, Default::default());\ncore/modules/tests.rs:1220:    let _ = runtime.poll_event_loop(cx, Default::default());\ncore/uv_compat.rs:184:  /// When integrated with `JsRuntime::poll_event_loop_inner`, the individual\ncore/uv_compat.rs:943:/// `poll_event_loop`. This function is useful for C-only consumers or testing.\ntesting/checkin/runner/ops_worker.rs:158:      .poll_event_loop(cx, PollEventLoopOptions::default())\ncore/runtime/jsruntime.rs:1883:    poll_fn(|cx| self.poll_event_loop(cx, poll_options)).await\ncore/runtime/jsruntime.rs:1903:      if let Poll::Ready(t) = self.poll_event_loop(cx, poll_options) {\ncore/runtime/jsruntime.rs:1933:      if let Poll::Ready(t) = self.poll_event_loop(cx, poll_options) {\ncore/runtime/jsruntime.rs:1948:  pub fn poll_event_loop(\ncore/runtime/jsruntime.rs:1960:    self.poll_event_loop_inner(cx, \u0026mut scope, poll_options)\ncore/runtime/jsruntime.rs:1973:  fn poll_event_loop_inner(\ncore/runtime/tests/misc.rs:113:      .poll_event_loop(\u0026mut Context::from_waker(\u0026waker), Default::default());\ncore/runtime/tests/misc.rs:659:    match runtime.poll_event_loop(cx, Default::default()) {\ncore/runtime/tests/misc.rs:818:    runtime.poll_event_loop(cx, Default::default()),\ncore/runtime/tests/misc.rs:825:    runtime.poll_event_loop(cx, Default::default()),\ncore/runtime/tests/misc.rs:830:    runtime.poll_event_loop(cx, Default::default()),\ncore/runtime/tests/misc.rs:835:    runtime.poll_event_loop(cx, Default::default()),\ncore/runtime/tests/misc.rs:847:    runtime.poll_event_loop(cx, Default::default()),\ncore/runtime/tests/misc.rs:852:    runtime.poll_event_loop(cx, Default::default()),\ncore/runtime/tests/misc.rs:1263:  poll_fn(|cx| runtime.poll_event_loop(cx, Default::default()))\ncore/runtime/tests/misc.rs:1294:    poll_fn(|cx| runtime.poll_event_loop(cx, Default::default()))\ncore/runtime/tests/misc.rs:1326:    poll_fn(|cx| runtime.poll_event_loop(cx, Default::default()))\ncore/runtime/tests/error.rs:29:    if let Poll::Ready(Err(_)) = runtime.poll_event_loop(cx, Default::default())\ncore/runtime/tests/jsrealm.rs:110:      runtime.poll_event_loop(cx, Default::default()),\ncore/runtime/tests/jsrealm.rs:125:      runtime.poll_event_loop(cx, Default::default()),\n",
      "is_error": false,
      "duration_ms": 45
    },
    {
      "tool": "read_file",
      "input": {
        "path": "core/runtime/jsruntime.rs"
      },
      "output": "// Copyright 2018-2025 the Deno authors. MIT license.\n\nuse super::SnapshotStoreDataStore;\nuse super::SnapshottedData;\nuse super::bindings;\nuse super::bindings::create_exports_for_ops_virtual_module;\nuse super::bindings::watch_promise;\nuse super::exception_state::ExceptionState;\nuse super::jsrealm::JsRealmInner;\nuse super::op_driver::OpDriver;\nuse super::setup;\nuse super::snapshot;\nuse super::stats::RuntimeActivityStatsFactory;\nuse super::v8_static_strings::*;\nuse crate::Extension;\nuse crate::ExtensionArguments;\nuse crate::ExtensionFileSource;\nuse crate::ExtensionFileSourceCode;\nuse crate::FastStaticString;\nuse crate::FastString;\nuse crate::ModuleCodeString;\nuse crate::NoopModuleLoader;\nuse crate::OpMetadata;\nuse crate::OpMetricsEvent;\nuse crate::OpStackTraceCallback;\nuse crate::OpState;\nuse crate::ascii_str;\nuse crate::ascii_str_include;\nuse crate::cppgc::FunctionTemplateData;\nuse crate::error::CoreError;\nuse crate::error::CoreErrorKind;\nuse crate::error::CoreModuleExecuteError;\nuse crate::error::CoreModuleParseError;\nuse crate::error::ExtensionLazyInitCountMismatchError;\nuse crate::error::ExtensionLazyInitOrderMismatchError;\nuse crate::error::JsError;\nuse crate::error::exception_to_err_result;\nuse crate::extension_set;\nuse crate::extension_set::LoadedSources;\nuse crate::extensions::GlobalObjectMiddlewareFn;\nuse crate::extensions::GlobalTemplateMiddlewareFn;\nuse crate::inspector::JsRuntimeInspector;\nuse crate::module_specifier::ModuleSpecifier;\nuse crate::modules::CustomModuleEvaluationCb;\nuse crate::modules::EvalContextCodeCacheReadyCb;\nuse crate::modules::EvalContextGetCodeCacheCb;\nuse crate::modules::ExtCodeCache;\nuse crate::modules::ExtModuleLoader;\nuse crate::modules::IntoModuleCodeString;\nuse crate::modules::IntoModuleName;\nuse crate::modules::ModuleId;\nuse crate::modules::ModuleLoader;\nuse crate::modules::ModuleMap;\nuse crate::modules::ModuleName;\nuse crate::modules::RequestedModuleType;\nuse crate::modules::ValidateImportAttributesCb;\nuse crate::modules::script_origin;\nuse crate::ops_metrics::OpMetricsFactoryFn;\nuse crate::ops_metrics::dispatch_metrics_async;\nuse crate::runtime::ContextState;\nuse crate::runtime::JsRealm;\nuse crate::runtime::OpDriverImpl;\nuse crate::runtime::jsrealm;\nuse crate::source_map::SourceMapData;\nuse crate::source_map::SourceMapper;\nuse crate::stats::RuntimeActivityType;\nuse deno_error::JsErrorBox;\nuse futures::FutureExt;\nuse futures::task::AtomicWaker;\nuse smallvec::SmallVec;\nuse std::any::Any;\nuse std::future::Future;\nuse std::future::poll_fn;\n\nuse std::cell::Cell;\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::collections::VecDeque;\nuse std::ffi::c_void;\nuse std::mem::ManuallyDrop;\nuse std::ops::Deref;\nuse std::ops::DerefMut;\nuse std::pin::Pin;\nuse std::rc::Rc;\nuse std::sync::Arc;\nuse std::sync::Mutex;\nuse std::task::Context;\nuse std::task::Poll;\nuse std::task::Waker;\n\npub type WaitForInspectorDisconnectCallback = Box\u003cdyn Fn()\u003e;\nconst STATE_DATA_OFFSET: u32 = 0;\n\npub type ExtensionTranspiler =\n  dyn Fn(\n    ModuleName,\n    ModuleCodeString,\n  ) -\u003e Result\u003c(ModuleCodeString, Option\u003cSourceMapData\u003e), JsErrorBox\u003e;\n\n/// Objects that need to live as long as the isolate\n#[derive(Default)]\npub(crate) struct IsolateAllocations {\n  pub(crate) externalized_sources: Box\u003c[v8::OneByteConst]\u003e,\n  pub(crate) original_sources: Box\u003c[FastString]\u003e,\n  pub(crate) near_heap_limit_callback_data:\n    Option\u003c(Box\u003cRefCell\u003cdyn Any\u003e\u003e, v8::NearHeapLimitCallback)\u003e,\n}\n\n/// ManuallyDrop\u003cRc\u003c...\u003e\u003e is clone, but it returns a ManuallyDrop\u003cRc\u003c...\u003e\u003e which is a massive\n/// memory-leak footgun.\npub(crate) struct ManuallyDropRc\u003cT\u003e(ManuallyDrop\u003cRc\u003cT\u003e\u003e);\n\nimpl\u003cT\u003e ManuallyDropRc\u003cT\u003e {\n  #[allow(unused)]\n  pub fn clone(\u0026self) -\u003e Rc\u003cT\u003e {\n    self.0.deref().clone()\n  }\n}\n\nimpl\u003cT\u003e Deref for ManuallyDropRc\u003cT\u003e {\n  type Target = Rc\u003cT\u003e;\n  fn deref(\u0026self) -\u003e \u0026Self::Target {\n    self.0.deref()\n  }\n}\n\nimpl\u003cT\u003e DerefMut for ManuallyDropRc\u003cT\u003e {\n  fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n    self.0.deref_mut()\n  }\n}\n\n/// This struct contains the [`JsRuntimeState`] and [`v8::OwnedIsolate`] that are required\n/// to do an orderly shutdown of V8. We keep these in a separate struct to allow us to control\n/// the destruction more closely, as snapshots require the isolate to be destroyed by the\n/// snapshot process, not the destructor.\n///\n/// The way rusty_v8 works w/snapshots is that the [`v8::OwnedIsolate`] gets consumed by a\n/// [`v8::snapshot::SnapshotCreator`] that is stored in its annex. It's a bit awkward, because this\n/// means we cannot let it drop (because we don't have it after a snapshot). On top of that, we have\n/// to consume it in the snapshot creator because otherwise it panics.\n///\n/// This inner struct allows us to let the outer JsRuntime drop normally without a Drop impl, while we\n/// control dropping more closely here using ManuallyDrop.\npub(crate) struct InnerIsolateState {\n  will_snapshot: bool,\n  extensions: Vec\u003c\u0026'static str\u003e,\n  op_count: usize,\n  source_count: usize,\n  addl_refs_count: usize,\n  main_realm: ManuallyDrop\u003cJsRealm\u003e,\n  pub(crate) state: ManuallyDropRc\u003cJsRuntimeState\u003e,\n  v8_isolate: ManuallyDrop\u003cv8::OwnedIsolate\u003e,\n}\n\nimpl InnerIsolateState {\n  /// Clean out the opstate and take the inspector to prevent the inspector from getting destroyed\n  /// after we've torn down the contexts. If the inspector is not correctly torn down, random crashes\n  /// happen in tests (and possibly for users using the inspector).\n  pub fn prepare_for_cleanup(\u0026mut self) {\n    // Explicitly shut down the op driver here, just in case there are other references to it\n    // that prevent it from dropping after we invalidate the state.\n    self.main_realm.0.context_state.pending_ops.shutdown();\n    let inspector = self.state.inspector.take();\n    self.state.op_state.borrow_mut().clear();\n    if let Some(inspector) = inspector {\n      assert_eq!(\n        Rc::strong_count(\u0026inspector),\n        1,\n        \"The inspector must be dropped before the runtime\"\n      );\n    }\n  }\n\n  pub fn cleanup(\u0026mut self) {\n    self.prepare_for_cleanup();\n\n    let state_ptr = self.v8_isolate.get_data(STATE_DATA_OFFSET);\n    // SAFETY: We are sure that it's a valid pointer for whole lifetime of\n    // the runtime.\n    _ = unsafe { Rc::from_raw(state_ptr as *const JsRuntimeState) };\n\n    unsafe {\n      ManuallyDrop::take(\u0026mut self.main_realm).0.destroy();\n    }\n\n    debug_assert_eq!(Rc::strong_count(\u0026self.state), 1);\n  }\n\n  pub fn prepare_for_snapshot(mut self) -\u003e v8::OwnedIsolate {\n    self.cleanup();\n\n    // SAFETY: We're copying out of self and then immediately forgetting self\n    unsafe {\n      ManuallyDrop::drop(\u0026mut self.state.0);\n\n      let isolate = ManuallyDrop::take(\u0026mut self.v8_isolate);\n\n      std::mem::forget(self);\n\n      isolate\n    }\n  }\n}\n\nimpl Drop for InnerIsolateState {\n  fn drop(\u0026mut self) {\n    self.cleanup();\n    // SAFETY: We gotta drop these\n    unsafe {\n      ManuallyDrop::drop(\u0026mut self.state.0);\n\n      if self.will_snapshot {\n        // Create the snapshot and just drop it.\n        #[allow(clippy::print_stderr)]\n        {\n          eprintln!(\"WARNING: v8::OwnedIsolate for snapshot was leaked\");\n        }\n      } else {\n        ManuallyDrop::drop(\u0026mut self.v8_isolate);\n      }\n    }\n  }\n}\n\n#[derive(Copy, Clone, Debug, Eq, PartialEq)]\npub(crate) enum InitMode {\n  /// We have no snapshot -- this is a pristine context.\n  New,\n  /// We are using a snapshot, thus certain initialization steps are skipped.\n  FromSnapshot {\n    // Can we skip the work of op registration?\n    skip_op_registration: bool,\n  },\n}\n\nimpl InitMode {\n  fn from_options(options: \u0026RuntimeOptions) -\u003e Self {\n    match options.startup_snapshot {\n      None =\u003e Self::New,\n      Some(_) =\u003e Self::FromSnapshot {\n        skip_op_registration: options.skip_op_registration,\n      },\n    }\n  }\n\n  #[inline]\n  pub fn needs_ops_bindings(\u0026self) -\u003e bool {\n    !matches!(\n      self,\n      InitMode::FromSnapshot {\n        skip_op_registration: true\n      }\n    )\n  }\n}\n\n#[derive(Default)]\nstruct PromiseFuture {\n  resolved: Cell\u003cOption\u003cResult\u003cv8::Global\u003cv8::Value\u003e, Box\u003cJsError\u003e\u003e\u003e\u003e,\n  waker: Cell\u003cOption\u003cWaker\u003e\u003e,\n}\n\n#[derive(Clone, Default)]\nstruct RcPromiseFuture(Rc\u003cPromiseFuture\u003e);\n\nimpl RcPromiseFuture {\n  pub fn new(res: Result\u003cv8::Global\u003cv8::Value\u003e, Box\u003cJsError\u003e\u003e) -\u003e Self {\n    Self(Rc::new(PromiseFuture {\n      resolved: Some(res).into(),\n      ..Default::default()\n    }))\n  }\n}\n\nimpl Future for RcPromiseFuture {\n  type Output = Result\u003cv8::Global\u003cv8::Value\u003e, Box\u003cJsError\u003e\u003e;\n\n  fn poll(self: Pin\u003c\u0026mut Self\u003e, cx: \u0026mut Context\u003c'_\u003e) -\u003e Poll\u003cSelf::Output\u003e {\n    let this = self.get_mut();\n    match this.0.resolved.take() {\n      Some(resolved) =\u003e Poll::Ready(resolved),\n      _ =\u003e {\n        this.0.waker.set(Some(cx.waker().clone()));\n        Poll::Pending\n      }\n    }\n  }\n}\n\nstatic VIRTUAL_OPS_MODULE_NAME: FastStaticString = ascii_str!(\"ext:core/ops\");\n\npub(crate) struct InternalSourceFile {\n  pub specifier: FastStaticString,\n  pub source: FastStaticString,\n}\n\nmacro_rules! internal_source_file {\n  ($str_:literal) =\u003e {{\n    InternalSourceFile {\n      specifier: ascii_str!(concat!(\"ext:core/\", $str_)),\n      source: ascii_str_include!(concat!(\"../\", $str_)),\n    }\n  }};\n}\n\n/// These files are executed just after a new context is created. They provided\n/// the necessary infrastructure to bind ops.\npub(crate) static CONTEXT_SETUP_SOURCES: [InternalSourceFile; 2] = [\n  internal_source_file!(\"00_primordials.js\"),\n  internal_source_file!(\"00_infra.js\"),\n];\n\n/// These files are executed when we start setting up extensions. They rely\n/// on ops being already fully set up.\npub(crate) static BUILTIN_SOURCES: [InternalSourceFile; 1] =\n  [internal_source_file!(\"01_core.js\")];\n\n/// Executed after `BUILTIN_SOURCES` are executed. Provides a thin ES module\n/// that exports `core`, `internals` and `primordials` objects.\npub(crate) static BUILTIN_ES_MODULES: [ExtensionFileSource; 1] =\n  [ExtensionFileSource::new(\n    \"ext:core/mod.js\",\n    ascii_str_include!(\"../mod.js\"),\n  )];\n\n/// We have `ext:core/ops` and `ext:core/mod.js` that are always provided.\n#[cfg(test)]\npub(crate) const NO_OF_BUILTIN_MODULES: usize = 2;\n\n/// A single execution context of JavaScript. Corresponds roughly to the \"Web\n/// Worker\" concept in the DOM.\n///\n/// The JsRuntime future completes when there is an error or when all\n/// pending ops have completed.\n///\n/// Use [`JsRuntimeForSnapshot`] to be able to create a snapshot.\n///\n/// Note: since V8 11.6, all runtimes must have a common parent thread that\n/// initalized the V8 platform. This can be done by calling\n/// [`JsRuntime::init_platform`] explicitly, or it will be done automatically on\n/// the calling thread when the first runtime is created.\npub struct JsRuntime {\n  pub(crate) inner: InnerIsolateState,\n  pub(crate) allocations: IsolateAllocations,\n  // Contains paths of source files that were executed in\n  // [`JsRuntime::init_extension_js`]. This field is populated only if a\n  // snapshot is being created.\n  files_loaded_from_fs_during_snapshot: Vec\u003c\u0026'static str\u003e,\n  // Marks if this is considered the top-level runtime. Used only by inspector.\n  is_main_runtime: bool,\n}\n\n/// The runtime type used for snapshot creation.\npub struct JsRuntimeForSnapshot(JsRuntime);\n\nimpl Deref for JsRuntimeForSnapshot {\n  type Target = JsRuntime;\n\n  fn deref(\u0026self) -\u003e \u0026Self::Target {\n    \u0026self.0\n  }\n}\n\nimpl DerefMut for JsRuntimeForSnapshot {\n  fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n    \u0026mut self.0\n  }\n}\n\npub struct CrossIsolateStore\u003cT\u003e(Arc\u003cMutex\u003cCrossIsolateStoreInner\u003cT\u003e\u003e\u003e);\n\nstruct CrossIsolateStoreInner\u003cT\u003e {\n  map: HashMap\u003cu32, T\u003e,\n  last_id: u32,\n}\n\nimpl\u003cT\u003e CrossIsolateStore\u003cT\u003e {\n  pub(crate) fn insert(\u0026self, value: T) -\u003e u32 {\n    let mut store = self.0.lock().unwrap();\n    let last_id = store.last_id;\n    store.map.insert(last_id, value);\n    store.last_id += 1;\n    last_id\n  }\n\n  pub(crate) fn take(\u0026self, id: u32) -\u003e Option\u003cT\u003e {\n    let mut store = self.0.lock().unwrap();\n    store.map.remove(\u0026id)\n  }\n}\n\nimpl\u003cT\u003e Default for CrossIsolateStore\u003cT\u003e {\n  fn default() -\u003e Self {\n    CrossIsolateStore(Arc::new(Mutex::new(CrossIsolateStoreInner {\n      map: Default::default(),\n      last_id: 0,\n    })))\n  }\n}\n\nimpl\u003cT\u003e Clone for CrossIsolateStore\u003cT\u003e {\n  fn clone(\u0026self) -\u003e Self {\n    Self(self.0.clone())\n  }\n}\n\npub type SharedArrayBufferStore =\n  CrossIsolateStore\u003cv8::SharedRef\u003cv8::BackingStore\u003e\u003e;\n\npub type CompiledWasmModuleStore = CrossIsolateStore\u003cv8::CompiledWasmModule\u003e;\n\n/// Internal state for JsRuntime which is stored in one of v8::Isolate's\n/// embedder slots.\npub struct JsRuntimeState {\n  pub(crate) source_mapper: Rc\u003cRefCell\u003cSourceMapper\u003e\u003e,\n  pub(crate) op_state: Rc\u003cRefCell\u003cOpState\u003e\u003e,\n  pub(crate) shared_array_buffer_store: Option\u003cSharedArrayBufferStore\u003e,\n  pub(crate) compiled_wasm_module_store: Option\u003cCompiledWasmModuleStore\u003e,\n  wait_for_inspector_disconnect_callback:\n    Option\u003cWaitForInspectorDisconnectCallback\u003e,\n  pub(crate) validate_import_attributes_cb: Option\u003cValidateImportAttributesCb\u003e,\n  pub(crate) custom_module_evaluation_cb: Option\u003cCustomModuleEvaluationCb\u003e,\n  pub(crate) eval_context_get_code_cache_cb:\n    RefCell\u003cOption\u003cEvalContextGetCodeCacheCb\u003e\u003e,\n  pub(crate) eval_context_code_cache_ready_cb:\n    RefCell\u003cOption\u003cEvalContextCodeCacheReadyCb\u003e\u003e,\n  pub(crate) cppgc_template: RefCell\u003cOption\u003cv8::Global\u003cv8::FunctionTemplate\u003e\u003e\u003e,\n  pub(crate) function_templates: Rc\u003cRefCell\u003cFunctionTemplateData\u003e\u003e,\n  pub(crate) callsite_prototype: RefCell\u003cOption\u003cv8::Global\u003cv8::Object\u003e\u003e\u003e,\n  waker: Arc\u003cAtomicWaker\u003e,\n  /// Accessed through [`JsRuntimeState::with_inspector`].\n  inspector: RefCell\u003cOption\u003cRc\u003cJsRuntimeInspector\u003e\u003e\u003e,\n  has_inspector: Cell\u003cbool\u003e,\n  lazy_extensions: Vec\u003c\u0026'static str\u003e,\n}\n\n#[derive(Default)]\npub struct RuntimeOptions {\n  /// Implementation of `ModuleLoader` which will be\n  /// called when V8 requests to load ES modules in the main realm.\n  ///\n  /// If not provided runtime will error if code being\n  /// executed tries to load modules.\n  pub module_loader: Option\u003cRc\u003cdyn ModuleLoader\u003e\u003e,\n\n  /// If specified, enables V8 code cache for extension code.\n  pub extension_code_cache: Option\u003cRc\u003cdyn ExtCodeCache\u003e\u003e,\n\n  /// If specified, transpiles extensions before loading.\n  pub extension_transpiler: Option\u003cRc\u003cExtensionTranspiler\u003e\u003e,\n\n  /// Provide a function that may optionally provide a metrics collector\n  /// for a given op.\n  pub op_metrics_factory_fn: Option\u003cOpMetricsFactoryFn\u003e,\n\n  /// JsRuntime extensions, not to be confused with ES modules.\n  /// Only ops registered by extensions will be initialized. If you need\n  /// to execute JS code from extensions, pass source files in `js` or `esm`\n  /// option on `ExtensionBuilder`.\n  ///\n  /// If you are creating a runtime from a snapshot take care not to include\n  /// JavaScript sources in the extensions.\n  pub extensions: Vec\u003cExtension\u003e,\n\n  /// V8 snapshot that should be loaded on startup.\n  ///\n  /// For testing, use `runtime.snapshot()` and then [`Box::leak`] to acquire\n  // a static slice.\n  pub startup_snapshot: Option\u003c\u0026'static [u8]\u003e,\n\n  /// Should op registration be skipped?\n  pub skip_op_registration: bool,\n\n  /// Isolate creation parameters.\n  pub create_params: Option\u003cv8::CreateParams\u003e,\n\n  /// V8 platform instance to use. Used when Deno initializes V8\n  /// (which it only does once), otherwise it's silently dropped.\n  pub v8_platform: Option\u003cv8::SharedRef\u003cv8::Platform\u003e\u003e,\n\n  /// The store to use for transferring SharedArrayBuffers between isolates.\n  /// If multiple isolates should have the possibility of sharing\n  /// SharedArrayBuffers, they should use the same [SharedArrayBufferStore]. If\n  /// no [SharedArrayBufferStore] is specified, SharedArrayBuffer can not be\n  /// serialized.\n  pub shared_array_buffer_store: Option\u003cSharedArrayBufferStore\u003e,\n\n  /// The store to use for transferring `WebAssembly.Module` objects between\n  /// isolates.\n  /// If multiple isolates should have the possibility of sharing\n  /// `WebAssembly.Module` objects, they should use the same\n  /// [CompiledWasmModuleStore]. If no [CompiledWasmModuleStore] is specified,\n  /// `WebAssembly.Module` objects cannot be serialized.\n  pub compiled_wasm_module_store: Option\u003cCompiledWasmModuleStore\u003e,\n\n  /// Start inspector instance to allow debuggers to connect.\n  pub inspector: bool,\n\n  /// Describe if this is the main runtime instance, used by debuggers in some\n  /// situation - like disconnecting when program finishes running.\n  pub is_main: bool,\n\n  /// Worker ID for inspector context naming (e.g., \"worker [1]\", \"worker [2]\").\n  /// Only used when `is_main` is false. Starts at 1.\n  pub worker_id: Option\u003cu32\u003e,\n\n  #[cfg(any(test, feature = \"unsafe_runtime_options\"))]\n  /// Should this isolate expose the v8 natives (eg: %OptimizeFunctionOnNextCall) and\n  /// GC control functions (`gc()`)? WARNING: This should not be used for production code as\n  /// this may expose the runtime to security vulnerabilities.\n  pub unsafe_expose_natives_and_gc: bool,\n\n  /// A callback that can be used to validate import attributes received at\n  /// the import site. If no callback is provided, all attributes are allowed.\n  ///\n  /// Embedders might use this callback to eg. validate value of \"type\"\n  /// attribute, not allowing other types than \"JSON\".\n  ///\n  /// To signal validation failure, users should throw an V8 exception inside\n  /// the callback.\n  pub validate_import_attributes_cb: Option\u003cValidateImportAttributesCb\u003e,\n\n  /// A callback that is called when the event loop has no more work to do,\n  /// but there are active, non-blocking inspector session (eg. Chrome\n  /// DevTools inspector is connected). The embedder can use this callback\n  /// to eg. print a message notifying user about program finished running.\n  /// This callback can be called multiple times, eg. after the program finishes\n  /// more work can be scheduled from the DevTools.\n  pub wait_for_inspector_disconnect_callback:\n    Option\u003cWaitForInspectorDisconnectCallback\u003e,\n\n  /// A callback that allows to evaluate a custom type of a module - eg.\n  /// embedders might implement loading WASM or test modules.\n  pub custom_module_evaluation_cb: Option\u003cCustomModuleEvaluationCb\u003e,\n\n  /// Callbacks to retrieve and store code cache for scripts evaluated\n  /// through evalContext.\n  pub eval_context_code_cache_cbs:\n    Option\u003c(EvalContextGetCodeCacheCb, EvalContextCodeCacheReadyCb)\u003e,\n\n  /// A callback to specify how stack traces should be used when an op is\n  /// annotated with `stack_trace` attribute. Use wisely, as it's very expensive\n  /// to collect stack traces on each op invocation.\n  pub maybe_op_stack_trace_callback: Option\u003cOpStackTraceCallback\u003e,\n}\n\nimpl RuntimeOptions {\n  #[cfg(any(test, feature = \"unsafe_runtime_options\"))]\n  fn unsafe_expose_natives_and_gc(\u0026self) -\u003e bool {\n    self.unsafe_expose_natives_and_gc\n  }\n\n  #[cfg(not(any(test, feature = \"unsafe_runtime_options\")))]\n  fn unsafe_expose_natives_and_gc(\u0026self) -\u003e bool {\n    false\n  }\n}\n\n#[derive(Copy, Clone, Debug)]\npub struct PollEventLoopOptions {\n  pub wait_for_inspector: bool,\n  pub pump_v8_message_loop: bool,\n}\n\nimpl Default for PollEventLoopOptions {\n  fn default() -\u003e Self {\n    Self {\n      wait_for_inspector: false,\n      pump_v8_message_loop: true,\n    }\n  }\n}\n\n#[derive(Default)]\npub struct CreateRealmOptions {\n  /// Implementation of `ModuleLoader` which will be\n  /// called when V8 requests to load ES modules in the realm.\n  ///\n  /// If not provided, there will be an error if code being\n  /// executed tries to load modules from the realm.\n  pub module_loader: Option\u003cRc\u003cdyn ModuleLoader\u003e\u003e,\n}\n\n#[macro_export]\nmacro_rules! scope {\n  ($scope: ident, $self: expr) =\u003e {\n    let context = $self.main_context();\n    let isolate = \u0026mut *$self.v8_isolate();\n    $crate::v8::scope!($scope, isolate);\n    let context = $crate::v8::Local::new($scope, context);\n    let $scope = \u0026mut $crate::v8::ContextScope::new($scope, context);\n  };\n}\n\nimpl JsRuntime {\n  /// Explicitly initalizes the V8 platform using the passed platform. This\n  /// should only be called once per process. Further calls will be silently\n  /// ignored.\n  #[cfg(not(any(test, feature = \"unsafe_runtime_options\")))]\n  pub fn init_platform(v8_platform: Option\u003cv8::SharedRef\u003cv8::Platform\u003e\u003e) {\n    setup::init_v8(v8_platform, cfg!(test), false);\n  }\n\n  /// Explicitly initalizes the V8 platform using the passed platform. This\n  /// should only be called once per process. Further calls will be silently\n  /// ignored.\n  ///\n  /// The `expose_natives` flag is used to expose the v8 natives\n  /// (eg: %OptimizeFunctionOnNextCall) and GC control functions (`gc()`).\n  /// WARNING: This should not be used for production code as\n  /// this may expose the runtime to security vulnerabilities.\n  #[cfg(any(test, feature = \"unsafe_runtime_options\"))]\n  pub fn init_platform(\n    v8_platform: Option\u003cv8::SharedRef\u003cv8::Platform\u003e\u003e,\n    expose_natives: bool,\n  ) {\n    setup::init_v8(v8_platform, cfg!(test), expose_natives);\n  }\n\n  /// Only constructor, configuration is done through `options`.\n  /// Panics if the runtime cannot be initialized.\n  pub fn new(options: RuntimeOptions) -\u003e JsRuntime {\n    match Self::try_new(options) {\n      Ok(runtime) =\u003e runtime,\n      Err(err) =\u003e {\n        panic!(\n          \"Failed to initialize a JsRuntime: {}\",\n          err.print_with_cause()\n        );\n      }\n    }\n  }\n\n  /// Only constructor, configuration is done through `options`.\n  /// Returns an error if the runtime cannot be initialized.\n  pub fn try_new(mut options: RuntimeOptions) -\u003e Result\u003cJsRuntime, CoreError\u003e {\n    setup::init_v8(\n      options.v8_platform.take(),\n      cfg!(test),\n      options.unsafe_expose_natives_and_gc(),\n    );\n    JsRuntime::new_inner(options, false)\n  }\n\n  pub(crate) fn state_from(isolate: \u0026v8::Isolate) -\u003e Rc\u003cJsRuntimeState\u003e {\n    let state_ptr = isolate.get_data(STATE_DATA_OFFSET);\n    let state_rc =\n      // SAFETY: We are sure that it's a valid pointer for whole lifetime of\n      // the runtime.\n      unsafe { Rc::from_raw(state_ptr as *const JsRuntimeState) };\n    let state = state_rc.clone();\n    std::mem::forget(state_rc);\n    state\n  }\n\n  /// Returns the `OpState` associated with the passed `Isolate`.\n  pub fn op_state_from(isolate: \u0026v8::Isolate) -\u003e Rc\u003cRefCell\u003cOpState\u003e\u003e {\n    let state = Self::state_from(isolate);\n    state.op_state.clone()\n  }\n\n  pub(crate) fn has_more_work(scope: \u0026mut v8::PinScope) -\u003e bool {\n    EventLoopPendingState::new_from_scope(scope).is_pending()\n  }\n\n  /// Returns the `OpMetadata` associated with the op `name`.\n  /// Note this is linear with respect to the number of ops registered.\n  pub fn op_metadata(\u0026self, name: \u0026str) -\u003e Option\u003cOpMetadata\u003e {\n    let state = \u0026self.inner.main_realm.0.context_state;\n    state.op_ctxs.iter().find_map(|ctx| {\n      if ctx.decl.name == name {\n        Some(ctx.decl.metadata)\n      } else {\n        None\n      }\n    })\n  }\n\n  fn new_inner(\n    mut options: RuntimeOptions,\n    will_snapshot: bool,\n  ) -\u003e Result\u003cJsRuntime, CoreError\u003e {\n    let init_mode = InitMode::from_options(\u0026options);\n    let mut extensions = std::mem::take(\u0026mut options.extensions);\n    let mut isolate_allocations = IsolateAllocations::default();\n\n    let enable_stack_trace_in_ops =\n      options.maybe_op_stack_trace_callback.is_some();\n\n    // First let's create an `OpState` and contribute to it from extensions...\n    let mut op_state = OpState::new(options.maybe_op_stack_trace_callback);\n    let unrefed_ops = op_state.unrefed_ops.clone();\n\n    let lazy_extensions =\n      extension_set::setup_op_state(\u0026mut op_state, \u0026mut extensions);\n\n    // Load the sources and source maps\n    let mut files_loaded = Vec::with_capacity(128);\n    let loader = options\n      .module_loader\n      .unwrap_or_else(|| Rc::new(NoopModuleLoader));\n\n    let mut source_mapper = SourceMapper::new(loader.clone());\n\n    let (maybe_startup_snapshot, mut sidecar_data) = options\n      .startup_snapshot\n      .take()\n      .map(snapshot::deconstruct)\n      .unzip();\n\n    let mut sources = extension_set::into_sources_and_source_maps(\n      options.extension_transpiler.as_deref(),\n      \u0026extensions,\n      sidecar_data.as_ref().map(|s| \u0026*s.snapshot_data.extensions),\n      |source| {\n        mark_as_loaded_from_fs_during_snapshot(\u0026mut files_loaded, \u0026source.code)\n      },\n    )?;\n\n    for loaded_source in sources\n      .js\n      .iter()\n      .chain(sources.esm.iter())\n      .chain(sources.lazy_esm.iter())\n      .filter(|s| s.maybe_source_map.is_some())\n    {\n      source_mapper.add_ext_source_map(\n        loaded_source.specifier.try_clone().unwrap(),\n        loaded_source.maybe_source_map.clone().unwrap(),\n      );\n    }\n\n    // ...now let's set up ` JsRuntimeState`, we'll need to set some fields\n    // later, after `JsRuntime` is all set up...\n    let waker = op_state.waker.clone();\n    let op_state = Rc::new(RefCell::new(op_state));\n    let (eval_context_get_code_cache_cb, eval_context_set_code_cache_cb) =\n      options\n        .eval_context_code_cache_cbs\n        .map(|cbs| (Some(cbs.0), Some(cbs.1)))\n        .unwrap_or_default();\n    let state_rc = Rc::new(JsRuntimeState {\n      source_mapper: Rc::new(RefCell::new(source_mapper)),\n      shared_array_buffer_store: options.shared_array_buffer_store,\n      compiled_wasm_module_store: options.compiled_wasm_module_store,\n      wait_for_inspector_disconnect_callback: options\n        .wait_for_inspector_disconnect_callback,\n      op_state: op_state.clone(),\n      validate_import_attributes_cb: options.validate_import_attributes_cb,\n      custom_module_evaluation_cb: options.custom_module_evaluation_cb,\n      eval_context_get_code_cache_cb: RefCell::new(\n        eval_context_get_code_cache_cb,\n      ),\n      eval_context_code_cache_ready_cb: RefCell::new(\n        eval_context_set_code_cache_cb,\n      ),\n      waker,\n      // Some fields are initialized later after isolate is created\n      inspector: None.into(),\n      has_inspector: false.into(),\n      cppgc_template: None.into(),\n      function_templates: Default::default(),\n      callsite_prototype: None.into(),\n      lazy_extensions,\n    });\n\n    // ...now we're moving on to ops; set them up, create `OpCtx` for each op\n    // and get ready to actually create V8 isolate...\n    let (op_decls, mut op_method_decls) =\n      extension_set::init_ops(crate::ops_builtin::BUILTIN_OPS, \u0026mut extensions);\n\n    let op_driver = Rc::new(OpDriverImpl::default());\n    let op_metrics_factory_fn = options.op_metrics_factory_fn.take();\n\n    let (mut op_ctxs, methods_ctx_offset) = extension_set::create_op_ctxs(\n      op_decls,\n      \u0026mut op_method_decls,\n      op_metrics_factory_fn,\n      op_driver.clone(),\n      op_state.clone(),\n      state_rc.clone(),\n      enable_stack_trace_in_ops,\n    );\n\n    // ...ops are now almost fully set up; let's create a V8 isolate...\n    let (\n      global_template_middleware,\n      global_object_middlewares,\n      additional_references,\n    ) = extension_set::get_middlewares_and_external_refs(\u0026mut extensions);\n\n    // Capture the extension, op and source counts\n    let extensions = extensions.iter().map(|e| e.name).collect();\n    let op_count = op_ctxs.len();\n    let source_count = sources.len();\n    let addl_refs_count = additional_references.len();\n\n    let ops_in_snapshot = sidecar_data\n      .as_ref()\n      .map(|d| d.snapshot_data.op_count)\n      .unwrap_or_default();\n    let sources_in_snapshot = sidecar_data\n      .as_ref()\n      .map(|d| d.snapshot_data.source_count)\n      .unwrap_or_default();\n\n    let snapshot_sources: Vec\u003c\u0026[u8]\u003e = sidecar_data\n      .as_mut()\n      .map(|s| std::mem::take(\u0026mut s.snapshot_data.external_strings))\n      .unwrap_or_default();\n    (\n      isolate_allocations.externalized_sources,\n      isolate_allocations.original_sources,\n    ) = bindings::externalize_sources(\u0026mut sources, snapshot_sources);\n\n    let external_references = bindings::create_external_references(\n      \u0026op_ctxs,\n      \u0026additional_references,\n      \u0026isolate_allocations.externalized_sources,\n      ops_in_snapshot,\n      sources_in_snapshot,\n    );\n\n    let has_snapshot = maybe_startup_snapshot.is_some();\n    let mut isolate = setup::create_isolate(\n      will_snapshot,\n      options.create_params.take(),\n      maybe_startup_snapshot,\n      external_references.into(),\n    );\n\n    let isolate_ptr = unsafe { isolate.as_raw_isolate_ptr() };\n    // ...isolate is fully set up, we can forward its pointer to the ops to finish\n    // their' setup...\n    for op_ctx in op_ctxs.iter_mut() {\n      op_ctx.isolate = isolate_ptr;\n    }\n\n    op_state.borrow_mut().put(isolate_ptr);\n\n    // ...once ops and isolate are set up, we can create a `ContextState`...\n    let context_state = Rc::new(ContextState::new(\n      op_driver.clone(),\n      isolate_ptr,\n      op_ctxs,\n      op_method_decls,\n      methods_ctx_offset,\n      op_state.borrow().external_ops_tracker.clone(),\n      unrefed_ops,\n    ));\n\n    // TODO(bartlomieju): factor out\n    // Add the task spawners to the OpState\n    let spawner = context_state\n      .task_spawner_factory\n      .clone()\n      .new_same_thread_spawner();\n    op_state.borrow_mut().put(spawner);\n    let spawner = context_state\n      .task_spawner_factory\n      .clone()\n      .new_cross_thread_spawner();\n    op_state.borrow_mut().put(spawner);\n\n    // ...and with `ContextState` available we can set up V8 context...\n    let mut snapshotted_data = None;\n    let main_context = {\n      v8::scope!(let scope, \u0026mut isolate);\n\n      let cppgc_template = crate::cppgc::make_cppgc_template(scope);\n      state_rc\n        .cppgc_template\n        .borrow_mut()\n        .replace(v8::Global::new(scope, cppgc_template));\n\n      let context = create_context(\n        scope,\n        \u0026global_template_middleware,\n        \u0026global_object_middlewares,\n        has_snapshot,\n      );\n\n      // Get module map data from the snapshot\n      if let Some(raw_data) = sidecar_data {\n        snapshotted_data = Some(snapshot::load_snapshotted_data_from_snapshot(\n          scope, context, raw_data,\n        ));\n      }\n\n      v8::Global::new(scope, context)\n    };\n\n    let main_realm = {\n      v8::scope_with_context!(context_scope, \u0026mut isolate, \u0026main_context);\n      let scope = context_scope;\n      let context = v8::Local::new(scope, \u0026main_context);\n\n      let callsite_prototype = crate::error::make_callsite_prototype(scope);\n      state_rc\n        .callsite_prototype\n        .borrow_mut()\n        .replace(v8::Global::new(scope, callsite_prototype));\n\n      // ...followed by creation of `Deno.core` namespace, as well as internal\n      // infrastructure to provide JavaScript bindings for ops...\n      if init_mode == InitMode::New {\n        bindings::initialize_deno_core_namespace(scope, context, init_mode);\n        bindings::initialize_primordials_and_infra(scope)?;\n      }\n      // If we're creating a new runtime or there are new ops to register\n      // set up JavaScript bindings for them.\n      if init_mode.needs_ops_bindings() {\n        bindings::initialize_deno_core_ops_bindings(\n          scope,\n          context,\n          \u0026context_state.op_ctxs,\n          \u0026context_state.op_method_decls,\n          methods_ctx_offset,\n          \u0026mut state_rc.function_templates.borrow_mut(),\n        );\n      }\n\n      // SAFETY: Initialize the context state slot.\n      unsafe {\n        context.set_aligned_pointer_in_embedder_data(\n          super::jsrealm::CONTEXT_STATE_SLOT_INDEX,\n          Rc::into_raw(context_state.clone()) as *mut c_void,\n        );\n      }\n\n      let inspector = if options.inspector {\n        Some(JsRuntimeInspector::new(\n          isolate_ptr,\n          scope,\n          context,\n          options.is_main,\n          options.worker_id,\n        ))\n      } else {\n        None\n      };\n\n      // ...now that JavaScript bindings to ops are available we can deserialize\n      // modules stored in the snapshot (because they depend on the ops and external\n      // references must match properly) and recreate a module map...\n      let exception_state = context_state.exception_state.clone();\n      let module_map = Rc::new(ModuleMap::new(\n        loader,\n        state_rc.source_mapper.clone(),\n        exception_state.clone(),\n        will_snapshot,\n      ));\n\n      if let Some((snapshotted_data, mut data_store)) = snapshotted_data {\n        *exception_state.js_handled_promise_rejection_cb.borrow_mut() =\n          snapshotted_data\n            .js_handled_promise_rejection_cb\n            .map(|cb| data_store.get(scope, cb));\n        module_map.update_with_snapshotted_data(\n          scope,\n          \u0026mut data_store,\n          snapshotted_data.module_map_data,\n        );\n\n        if let Some(index) = snapshotted_data.ext_import_meta_proto {\n          *context_state.ext_import_meta_proto.borrow_mut() =\n            Some(data_store.get(scope, index));\n        }\n\n        state_rc\n          .function_templates\n          .borrow_mut()\n          .update_with_snapshotted_data(\n            scope,\n            \u0026mut data_store,\n            snapshotted_data.function_templates_data,\n          );\n\n        let mut mapper = state_rc.source_mapper.borrow_mut();\n        for (key, map) in snapshotted_data.ext_source_maps {\n          mapper.add_ext_source_map(ModuleName::from_static(key), map.into());\n        }\n      }\n\n      if context_state.ext_import_meta_proto.borrow().is_none() {\n        let null = v8::null(scope);\n        let obj = v8::Object::with_prototype_and_properties(\n          scope,\n          null.into(),\n          \u0026[],\n          \u0026[],\n        );\n        *context_state.ext_import_meta_proto.borrow_mut() =\n          Some(v8::Global::new(scope, obj));\n      }\n\n      // SAFETY: Set the module map slot in the context\n      unsafe {\n        context.set_aligned_pointer_in_embedder_data(\n          super::jsrealm::MODULE_MAP_SLOT_INDEX,\n          Rc::into_raw(module_map.clone()) as *mut c_void,\n        );\n      }\n\n      // ...we are ready to create a \"realm\" for the context...\n      let main_realm = {\n        let main_realm = JsRealmInner::new(\n          context_state,\n          main_context,\n          module_map.clone(),\n          state_rc.function_templates.clone(),\n        );\n        // TODO(bartlomieju): why is this done in here? Maybe we can hoist it out?\n        state_rc.has_inspector.set(inspector.is_some());\n        *state_rc.inspector.borrow_mut() = inspector;\n        main_realm\n      };\n      let main_realm = JsRealm::new(main_realm);\n      scope.set_data(\n        STATE_DATA_OFFSET,\n        Rc::into_raw(state_rc.clone()) as *mut c_void,\n      );\n      main_realm\n    };\n\n    // ...which allows us to create the `JsRuntime` instance...\n    let mut js_runtime = JsRuntime {\n      inner: InnerIsolateState {\n        will_snapshot,\n        op_count,\n        extensions,\n        source_count,\n        addl_refs_count,\n        main_realm: ManuallyDrop::new(main_realm),\n        state: ManuallyDropRc(ManuallyDrop::new(state_rc)),\n        v8_isolate: ManuallyDrop::new(isolate),\n      },\n      allocations: isolate_allocations,\n      files_loaded_from_fs_during_snapshot: vec![],\n      is_main_runtime: options.is_main,\n    };\n\n    // ...we're almost done with the setup, all that's left is to execute\n    // internal JS and then execute code provided by extensions...\n    {\n      let realm = JsRealm::clone(\u0026js_runtime.inner.main_realm);\n      let context_global = realm.context();\n      let module_map = realm.0.module_map();\n\n      // TODO(bartlomieju): this is somewhat duplicated in `bindings::initialize_context`,\n      // but for migration period we need to have ops available in both `Deno.core.ops`\n      // as well as have them available in \"virtual ops module\"\n      // if !matches!(\n      //   self.init_mode,\n      //   InitMode::FromSnapshot {\n      //     skip_op_registration: true\n      //   }\n      // ) {\n      if init_mode == InitMode::New {\n        js_runtime\n          .execute_virtual_ops_module(context_global, module_map.clone());\n      }\n\n      if init_mode == InitMode::New {\n        js_runtime.execute_builtin_sources(\n          \u0026realm,\n          \u0026module_map,\n          \u0026mut files_loaded,\n        )?;\n      }\n\n      js_runtime.store_js_callbacks(\u0026realm, will_snapshot);\n\n      js_runtime.init_extension_js(\n        \u0026realm,\n        \u0026module_map,\n        sources,\n        options.extension_code_cache,\n      )?;\n    }\n\n    if will_snapshot {\n      js_runtime.files_loaded_from_fs_during_snapshot = files_loaded;\n    }\n\n    // ...and we've made it; `JsRuntime` is ready to execute user code.\n    Ok(js_runtime)\n  }\n\n  /// If extensions were initialized with `lazy_init`, they need to be\n  /// fully initialized with this method.\n  pub fn lazy_init_extensions(\n    \u0026self,\n    ext_args: Vec\u003cExtensionArguments\u003e,\n  ) -\u003e Result\u003c(), CoreError\u003e {\n    if ext_args.len() != self.inner.state.lazy_extensions.len() {\n      return Err(\n        CoreErrorKind::ExtensionLazyInitCountMismatch(\n          ExtensionLazyInitCountMismatchError {\n            lazy_init_extensions_len: self.inner.state.lazy_extensions.len(),\n            arguments_len: ext_args.len(),\n          },\n        )\n        .into_box(),\n      );\n    }\n\n    let mut state = self.inner.state.op_state.borrow_mut();\n\n    for (mut args, expected_name) in ext_args\n      .into_iter()\n      .zip(self.inner.state.lazy_extensions.iter())\n    {\n      if args.name != *expected_name {\n        return Err(\n          CoreErrorKind::ExtensionLazyInitOrderMismatch(\n            ExtensionLazyInitOrderMismatchError {\n              expected: expected_name,\n              actual: args.name,\n            },\n          )\n          .into_box(),\n        );\n      }\n\n      let Some(f) = args.op_state_fn.take() else {\n        continue;\n      };\n\n      f(\u0026mut state);\n    }\n\n    Ok(())\n  }\n\n  pub fn set_eval_context_code_cache_cbs(\n    \u0026self,\n    eval_context_code_cache_cbs: Option\u003c(\n      EvalContextGetCodeCacheCb,\n      EvalContextCodeCacheReadyCb,\n    )\u003e,\n  ) {\n    let (eval_context_get_code_cache_cb, eval_context_set_code_cache_cb) =\n      eval_context_code_cache_cbs\n        .map(|cbs| (Some(cbs.0), Some(cbs.1)))\n        .unwrap_or_default();\n    *self.inner.state.eval_context_get_code_cache_cb.borrow_mut() =\n      eval_context_get_code_cache_cb;\n    *self\n      .inner\n      .state\n      .eval_context_code_cache_ready_cb\n      .borrow_mut() = eval_context_set_code_cache_cb;\n  }\n\n  #[cfg(test)]\n  #[inline]\n  pub(crate) fn module_map(\u0026self) -\u003e Rc\u003cModuleMap\u003e {\n    self.inner.main_realm.0.module_map()\n  }\n\n  #[inline]\n  pub fn main_context(\u0026self) -\u003e v8::Global\u003cv8::Context\u003e {\n    self.inner.main_realm.0.context().clone()\n  }\n\n  #[cfg(test)]\n  pub(crate) fn main_realm(\u0026self) -\u003e JsRealm {\n    JsRealm::clone(\u0026self.inner.main_realm)\n  }\n\n  #[inline]\n  pub fn v8_isolate(\u0026mut self) -\u003e \u0026mut v8::OwnedIsolate {\n    \u0026mut self.inner.v8_isolate\n  }\n\n  #[inline]\n  fn v8_isolate_ptr(\u0026mut self) -\u003e v8::UnsafeRawIsolatePtr {\n    unsafe { self.inner.v8_isolate.as_raw_isolate_ptr() }\n  }\n\n  #[inline]\n  pub fn inspector(\u0026self) -\u003e Rc\u003cJsRuntimeInspector\u003e {\n    self.inner.state.inspector()\n  }\n\n  #[inline]\n  pub fn wait_for_inspector_disconnect(\u0026self) {\n    if let Some(callback) = self\n      .inner\n      .state\n      .wait_for_inspector_disconnect_callback\n      .as_ref()\n    {\n      callback();\n    }\n  }\n\n  pub fn runtime_activity_stats_factory(\u0026self) -\u003e RuntimeActivityStatsFactory {\n    RuntimeActivityStatsFactory {\n      context_state: self.inner.main_realm.0.context_state.clone(),\n      op_state: self.inner.state.op_state.clone(),\n    }\n  }\n\n  // TODO(bartlomieju): remove, instead `JsRuntimeForSnapshot::new` should return\n  // a struct that contains this data.\n  pub(crate) fn files_loaded_from_fs_during_snapshot(\u0026self) -\u003e \u0026[\u0026'static str] {\n    \u0026self.files_loaded_from_fs_during_snapshot\n  }\n\n  /// Create a synthetic module - `ext:core/ops` - that exports all ops registered\n  /// with the runtime.\n  fn execute_virtual_ops_module(\n    \u0026mut self,\n    context_global: \u0026v8::Global\u003cv8::Context\u003e,\n    module_map: Rc\u003cModuleMap\u003e,\n  ) {\n    scope!(scope, self);\n    let context_local = v8::Local::new(scope, context_global);\n    let context_state = JsRealm::state_from_scope(scope);\n    let global = context_local.global(scope);\n    let synthetic_module_exports = create_exports_for_ops_virtual_module(\n      \u0026context_state.op_ctxs,\n      \u0026context_state.op_method_decls,\n      context_state.methods_ctx_offset,\n      scope,\n      global,\n    );\n    let mod_id = module_map.new_synthetic_module(\n      scope,\n      VIRTUAL_OPS_MODULE_NAME,\n      crate::ModuleType::JavaScript,\n      synthetic_module_exports,\n    );\n    module_map.mod_evaluate_sync(scope, mod_id).unwrap();\n  }\n\n  /// Executes built-in scripts and ES modules - this code is required for\n  /// ops system to work properly, as well as providing necessary bindings\n  /// on the `Deno.core` namespace.\n  ///\n  /// This is not done in [`bindings::initialize_primordials_and_infra`] because\n  /// some of this code already relies on certain ops being available.\n  fn execute_builtin_sources(\n    \u0026mut self,\n    _realm: \u0026JsRealm,\n    module_map: \u0026Rc\u003cModuleMap\u003e,\n    files_loaded: \u0026mut Vec\u003c\u0026'static str\u003e,\n  ) -\u003e Result\u003c(), CoreError\u003e {\n    scope!(scope, self);\n\n    for source_file in \u0026BUILTIN_SOURCES {\n      let name = source_file.specifier.v8_string(scope).unwrap();\n      let source = source_file.source.v8_string(scope).unwrap();\n\n      let origin = script_origin(scope, name, false, None);\n      let script = v8::Script::compile(scope, source, Some(\u0026origin))\n        .ok_or(CoreModuleParseError(source_file.specifier))?;\n      script\n        .run(scope)\n        .ok_or(CoreModuleExecuteError(source_file.specifier))?;\n    }\n\n    for file_source in \u0026BUILTIN_ES_MODULES {\n      mark_as_loaded_from_fs_during_snapshot(files_loaded, \u0026file_source.code);\n      module_map.lazy_load_es_module_with_code(\n        scope,\n        file_source.specifier,\n        file_source.load()?,\n        None,\n      )?;\n    }\n\n    Ok(())\n  }\n\n  /// Initializes JS of provided Extensions in the given realm.\n  async fn init_extension_js_inner(\n    \u0026mut self,\n    realm: \u0026JsRealm,\n    module_map: \u0026Rc\u003cModuleMap\u003e,\n    loaded_sources: LoadedSources,\n    ext_code_cache: Option\u003cRc\u003cdyn ExtCodeCache\u003e\u003e,\n  ) -\u003e Result\u003c(), CoreError\u003e {\n    // First, add all the lazy ESM\n    for source in loaded_sources.lazy_esm {\n      module_map.add_lazy_loaded_esm_source(source.specifier, source.code);\n    }\n\n    // Temporarily override the loader of the `ModuleMap` so we can load\n    // extension code.\n\n    // TODO(bartlomieju): maybe this should be a method on the `ModuleMap`,\n    // instead of explicitly changing the `.loader` field?\n    let loader = module_map.loader.borrow().clone();\n    let mut modules = Vec::with_capacity(loaded_sources.esm.len());\n    let mut sources = Vec::with_capacity(loaded_sources.esm.len());\n    for esm in loaded_sources.esm {\n      modules.push(ModuleSpecifier::parse(\u0026esm.specifier).unwrap());\n      sources.push((esm.specifier, esm.code));\n    }\n    let ext_loader =\n      Rc::new(ExtModuleLoader::new(sources, ext_code_cache.clone()));\n    *module_map.loader.borrow_mut() = ext_loader.clone();\n\n    // Next, load the extension modules as side modules (but do not execute them)\n    for module in modules {\n      // eprintln!(\"loading module: {module}\");\n      realm\n        .load_side_es_module_from_code(self.v8_isolate(), module.into(), None)\n        .await?;\n    }\n\n    // Execute extension scripts\n    for source in loaded_sources.js {\n      match \u0026ext_code_cache {\n        Some(ext_code_cache) =\u003e {\n          let specifier = ModuleSpecifier::parse(\u0026source.specifier)?;\n          realm.execute_script_with_cache(\n            self.v8_isolate(),\n            specifier,\n            source.code,\n            \u0026|specifier, code| {\n              ext_code_cache.get_code_cache_info(specifier, code, false)\n            },\n            \u0026|specifier, hash, code_cache| {\n              ext_code_cache\n                .code_cache_ready(specifier, hash, code_cache, false)\n            },\n          )?;\n        }\n        _ =\u003e {\n          realm.execute_script(\n            self.v8_isolate(),\n            source.specifier,\n            source.code,\n          )?;\n        }\n      }\n    }\n\n    // ...then execute all entry points\n    for specifier in loaded_sources.esm_entry_points {\n      let Some(mod_id) =\n        module_map.get_id(\u0026specifier, RequestedModuleType::None)\n      else {\n        return Err(\n          CoreErrorKind::MissingFromModuleMap(specifier.to_string()).into_box(),\n        );\n      };\n\n      let isolate = self.v8_isolate();\n      jsrealm::context_scope!(scope, realm, isolate);\n      module_map.mod_evaluate_sync(scope, mod_id)?;\n      let mut cx = Context::from_waker(Waker::noop());\n      // poll once so code cache is populated. the `ExtCodeCache` trait is sync, so\n      // the `CodeCacheReady` futures will always finish on the first poll.\n      let _ = module_map.poll_progress(\u0026mut cx, scope);\n    }\n\n    #[cfg(debug_assertions)]\n    {\n      jsrealm::context_scope!(scope, realm, self.v8_isolate());\n      module_map.check_all_modules_evaluated(scope)?;\n    }\n\n    let module_map = realm.0.module_map();\n    *module_map.loader.borrow_mut() = loader;\n    ext_loader.finalize()?;\n\n    Ok(())\n  }\n\n  /// Initializes JS of provided Extensions in the given realm.\n  fn init_extension_js(\n    \u0026mut self,\n    realm: \u0026JsRealm,\n    module_map: \u0026Rc\u003cModuleMap\u003e,\n    loaded_sources: LoadedSources,\n    ext_code_cache: Option\u003cRc\u003cdyn ExtCodeCache\u003e\u003e,\n  ) -\u003e Result\u003c(), CoreError\u003e {\n    futures::executor::block_on(self.init_extension_js_inner(\n      realm,\n      module_map,\n      loaded_sources,\n      ext_code_cache,\n    ))?;\n\n    Ok(())\n  }\n\n  pub fn eval\u003c's, 'i, T\u003e(\n    scope: \u0026mut v8::PinScope\u003c's, 'i\u003e,\n    code: \u0026str,\n  ) -\u003e Option\u003cv8::Local\u003c's, T\u003e\u003e\n  where\n    v8::Local\u003c's, T\u003e: TryFrom\u003cv8::Local\u003c's, v8::Value\u003e, Error = v8::DataError\u003e,\n  {\n    v8::escapable_handle_scope!(let scope, scope);\n    let source = v8::String::new(scope, code).unwrap();\n    let script = v8::Script::compile(scope, source, None).unwrap();\n    let v = script.run(scope)?;\n    scope.escape(v).try_into().ok()\n  }\n\n  /// Grab and store JavaScript bindings to callbacks necessary for the\n  /// JsRuntime to operate properly.\n  fn store_js_callbacks(\u0026mut self, realm: \u0026JsRealm, will_snapshot: bool) {\n    let (\n      resolve_ops_cb,\n      drain_next_tick_and_macrotasks_cb,\n      handle_rejections_cb,\n      set_timer_depth_cb,\n      report_exception_cb,\n      build_custom_error_cb,\n      run_immediate_callbacks_cb,\n      wasm_instance_fn,\n    ) = {\n      scope!(scope, self);\n      let context = realm.context();\n      let context_local = v8::Local::new(scope, context);\n      let global = context_local.global(scope);\n      let deno_obj: v8::Local\u003cv8::Object\u003e =\n        bindings::get(scope, global, DENO, \"Deno\");\n      let core_obj: v8::Local\u003cv8::Object\u003e =\n        bindings::get(scope, deno_obj, CORE, \"Deno.core\");\n\n      let resolve_ops_cb: v8::Local\u003cv8::Function\u003e = bindings::get(\n        scope,\n        core_obj,\n        RESOLVE_OPS,\n        \"Deno.core.__resolveOps\",\n      );\n      let drain_next_tick_and_macrotasks_cb: v8::Local\u003cv8::Function\u003e =\n        bindings::get(\n          scope,\n          core_obj,\n          DRAIN_NEXT_TICK_AND_MACROTASKS,\n          \"Deno.core.__drainNextTickAndMacrotasks\",\n        );\n      let handle_rejections_cb: v8::Local\u003cv8::Function\u003e = bindings::get(\n        scope,\n        core_obj,\n        HANDLE_REJECTIONS,\n        \"Deno.core.__handleRejections\",\n      );\n      let set_timer_depth_cb: v8::Local\u003cv8::Function\u003e = bindings::get(\n        scope,\n        core_obj,\n        SET_TIMER_DEPTH,\n        \"Deno.core.__setTimerDepth\",\n      );\n      let report_exception_cb: v8::Local\u003cv8::Function\u003e = bindings::get(\n        scope,\n        core_obj,\n        REPORT_EXCEPTION,\n        \"Deno.core.__reportException\",\n      );\n      let build_custom_error_cb: v8::Local\u003cv8::Function\u003e = bindings::get(\n        scope,\n        core_obj,\n        BUILD_CUSTOM_ERROR,\n        \"Deno.core.buildCustomError\",\n      );\n      let run_immediate_callbacks_cb: v8::Local\u003cv8::Function\u003e = bindings::get(\n        scope,\n        core_obj,\n        RUN_IMMEDIATE_CALLBACKS,\n        \"Deno.core.runImmediateCallbacks\",\n      );\n\n      let mut wasm_instance_fn = None;\n      if !will_snapshot {\n        let key = WEBASSEMBLY.v8_string(scope).unwrap();\n        if let Some(web_assembly_obj_value) = global.get(scope, key.into()) {\n          let maybe_web_assembly_object =\n            TryInto::\u003cv8::Local\u003cv8::Object\u003e\u003e::try_into(web_assembly_obj_value);\n          if let Ok(web_assembly_object) = maybe_web_assembly_object {\n            wasm_instance_fn = Some(bindings::get::\u003cv8::Local\u003cv8::Function\u003e\u003e(\n              scope,\n              web_assembly_object,\n              INSTANCE,\n              \"WebAssembly.Instance\",\n            ));\n          }\n        }\n      }\n\n      (\n        v8::Global::new(scope, resolve_ops_cb),\n        v8::Global::new(scope, drain_next_tick_and_macrotasks_cb),\n        v8::Global::new(scope, handle_rejections_cb),\n        v8::Global::new(scope, set_timer_depth_cb),\n        v8::Global::new(scope, report_exception_cb),\n        v8::Global::new(scope, build_custom_error_cb),\n        v8::Global::new(scope, run_immediate_callbacks_cb),\n        wasm_instance_fn.map(|f| v8::Global::new(scope, f)),\n      )\n    };\n\n    // Put global handles in the realm's ContextState\n    let state_rc = realm.0.state();\n    state_rc\n      .js_resolve_ops_cb\n      .borrow_mut()\n      .replace(resolve_ops_cb);\n    state_rc\n      .js_drain_next_tick_and_macrotasks_cb\n      .borrow_mut()\n      .replace(drain_next_tick_and_macrotasks_cb);\n    state_rc\n      .js_handle_rejections_cb\n      .borrow_mut()\n      .replace(handle_rejections_cb);\n    state_rc\n      .js_set_timer_depth_cb\n      .borrow_mut()\n      .replace(set_timer_depth_cb);\n    state_rc\n      .js_report_exception_cb\n      .borrow_mut()\n      .replace(report_exception_cb);\n    state_rc\n      .exception_state\n      .js_build_custom_error_cb\n      .borrow_mut()\n      .replace(build_custom_error_cb);\n    state_rc\n      .run_immediate_callbacks_cb\n      .borrow_mut()\n      .replace(run_immediate_callbacks_cb);\n    if let Some(wasm_instance_fn) = wasm_instance_fn {\n      state_rc\n        .wasm_instance_fn\n        .borrow_mut()\n        .replace(wasm_instance_fn);\n    }\n  }\n\n  /// Returns the runtime's op state, which can be used to maintain ops\n  /// and access resources between op calls.\n  pub fn op_state(\u0026self) -\u003e Rc\u003cRefCell\u003cOpState\u003e\u003e {\n    self.inner.state.op_state.clone()\n  }\n\n  /// Returns the runtime's op names, ordered by OpId.\n  pub fn op_names(\u0026self) -\u003e Vec\u003c\u0026'static str\u003e {\n    let state = \u0026self.inner.main_realm.0.context_state;\n    state.op_ctxs.iter().map(|o| o.decl.name).collect()\n  }\n\n  /// Executes traditional, non-ECMAScript-module JavaScript code, This code executes in\n  /// the global scope by default, and it is possible to maintain local JS state and invoke\n  /// this method multiple times.\n  ///\n  /// `name` may be any type that implements the internal [`IntoModuleName`] trait.\n  /// It can be a filepath or any other string, but it is required to be 7-bit ASCII, eg.\n  ///\n  ///   - \"/some/file/path.js\"\n  ///   - \"\u003canon\u003e\"\n  ///   - \"[native code]\"\n  ///\n  /// The same `name` value can be used for multiple executions.\n  ///\n  /// The source may be any type that implements the internal [`IntoModuleCodeString`] trait, but\n  /// it is highly recommended that embedders use the [`ascii_str!`] to generate the fastest version\n  /// of strings for v8 to handle. If the strings are not static, you may also pass a [`String`]\n  /// generated by the [`format!`] macro.\n  pub fn execute_script(\n    \u0026mut self,\n    name: impl IntoModuleName,\n    source_code: impl IntoModuleCodeString,\n  ) -\u003e Result\u003cv8::Global\u003cv8::Value\u003e, Box\u003cJsError\u003e\u003e {\n    let isolate = \u0026mut self.inner.v8_isolate;\n    self.inner.main_realm.execute_script(\n      isolate,\n      name.into_module_name(),\n      source_code.into_module_code(),\n    )\n  }\n\n  /// Call a function and return a future resolving with the return value of the\n  /// function. If the function returns a promise, the future will resolve only once the\n  /// event loop resolves the underlying promise. If the future rejects, the future will\n  /// resolve with the underlying error.\n  ///\n  /// The event loop must be polled seperately for this future to resolve. If the event loop\n  /// is not polled, the future will never make progress.\n  pub fn call(\n    \u0026mut self,\n    function: \u0026v8::Global\u003cv8::Function\u003e,\n  ) -\u003e impl Future\u003cOutput = Result\u003cv8::Global\u003cv8::Value\u003e, Box\u003cJsError\u003e\u003e\u003e + use\u003c\u003e\n  {\n    self.call_with_args(function, \u0026[])\n  }\n\n  /// Call a function and returns a future resolving with the return value of the\n  /// function. If the function returns a promise, the future will resolve only once the\n  /// event loop resolves the underlying promise. If the future rejects, the future will\n  /// resolve with the underlying error.\n  ///\n  /// The event loop must be polled seperately for this future to resolve. If the event loop\n  /// is not polled, the future will never make progress.\n  pub fn scoped_call(\n    scope: \u0026mut v8::PinScope,\n    function: \u0026v8::Global\u003cv8::Function\u003e,\n  ) -\u003e impl Future\u003cOutput = Result\u003cv8::Global\u003cv8::Value\u003e, Box\u003cJsError\u003e\u003e\u003e + use\u003c\u003e\n  {\n    Self::scoped_call_with_args(scope, function, \u0026[])\n  }\n\n  /// Call a function and returns a future resolving with the return value of the\n  /// function. If the function returns a promise, the future will resolve only once the\n  /// event loop resolves the underlying promise. If the future rejects, the future will\n  /// resolve with the underlying error.\n  ///\n  /// The event loop must be polled seperately for this future to resolve. If the event loop\n  /// is not polled, the future will never make progress.\n  pub fn call_with_args(\n    \u0026mut self,\n    function: \u0026v8::Global\u003cv8::Function\u003e,\n    args: \u0026[v8::Global\u003cv8::Value\u003e],\n  ) -\u003e impl Future\u003cOutput = Result\u003cv8::Global\u003cv8::Value\u003e, Box\u003cJsError\u003e\u003e\u003e + use\u003c\u003e\n  {\n    scope!(scope, self);\n    Self::scoped_call_with_args(scope, function, args)\n  }\n\n  /// Call a function and returns a future resolving with the return value of the\n  /// function. If the function returns a promise, the future will resolve only once the\n  /// event loop resolves the underlying promise. If the future rejects, the future will\n  /// resolve with the underlying error.\n  ///\n  /// The event loop must be polled seperately for this future to resolve. If the event loop\n  /// is not polled, the future will never make progress.\n  pub fn scoped_call_with_args(\n    scope: \u0026mut v8::PinScope,\n    function: \u0026v8::Global\u003cv8::Function\u003e,\n    args: \u0026[v8::Global\u003cv8::Value\u003e],\n  ) -\u003e impl Future\u003cOutput = Result\u003cv8::Global\u003cv8::Value\u003e, Box\u003cJsError\u003e\u003e\u003e + use\u003c\u003e\n  {\n    v8::tc_scope!(let scope, scope);\n    let cb = function.open(scope);\n    let this = v8::undefined(scope).into();\n    let promise = if args.is_empty() {\n      cb.call(scope, this, \u0026[])\n    } else {\n      let mut local_args: SmallVec\u003c[v8::Local\u003cv8::Value\u003e; 8]\u003e =\n        SmallVec::with_capacity(args.len());\n      for v in args {\n        local_args.push(v8::Local::new(scope, v));\n      }\n      cb.call(scope, this, \u0026local_args)\n    };\n\n    if promise.is_none() {\n      if scope.is_execution_terminating() {\n        let undefined = v8::undefined(scope).into();\n        return RcPromiseFuture::new(exception_to_err_result(\n          scope, undefined, false, true,\n        ));\n      }\n      let exception = scope.exception().unwrap();\n      return RcPromiseFuture::new(exception_to_err_result(\n        scope, exception, false, true,\n      ));\n    }\n    let promise = promise.unwrap();\n    if !promise.is_promise() {\n      return RcPromiseFuture::new(Ok(v8::Global::new(scope, promise)));\n    }\n    let promise = v8::Local::\u003cv8::Promise\u003e::try_from(promise).unwrap();\n    Self::resolve_promise_inner(scope, promise)\n  }\n\n  /// Call a function. If it returns a promise, run the event loop until that\n  /// promise is settled. If the promise rejects or there is an uncaught error\n  /// in the event loop, return `Err(error)`. Or return `Ok(\u003cawait returned\u003e)`.\n  #[deprecated = \"Use call\"]\n  pub async fn call_and_await(\n    \u0026mut self,\n    function: \u0026v8::Global\u003cv8::Function\u003e,\n  ) -\u003e Result\u003cv8::Global\u003cv8::Value\u003e, CoreError\u003e {\n    let call = self.call(function);\n    self\n      .with_event_loop_promise(call, PollEventLoopOptions::default())\n      .await\n  }\n\n  /// Call a function with args. If it returns a promise, run the event loop until that\n  /// promise is settled. If the promise rejects or there is an uncaught error\n  /// in the event loop, return `Err(error)`. Or return `Ok(\u003cawait returned\u003e)`.\n  #[deprecated = \"Use call_with_args\"]\n  pub async fn call_with_args_and_await(\n    \u0026mut self,\n    function: \u0026v8::Global\u003cv8::Function\u003e,\n    args: \u0026[v8::Global\u003cv8::Value\u003e],\n  ) -\u003e Result\u003cv8::Global\u003cv8::Value\u003e, CoreError\u003e {\n    let call = self.call_with_args(function, args);\n    self\n      .with_event_loop_promise(call, PollEventLoopOptions::default())\n      .await\n  }\n\n  /// Returns the namespace object of a module.\n  ///\n  /// This is only available after module evaluation has completed.\n  /// This function panics if module has not been instantiated.\n  pub fn get_module_namespace(\n    \u0026mut self,\n    module_id: ModuleId,\n  ) -\u003e Result\u003cv8::Global\u003cv8::Object\u003e, CoreError\u003e {\n    let isolate = \u0026mut self.inner.v8_isolate;\n    self\n      .inner\n      .main_realm\n      .get_module_namespace(isolate, module_id)\n  }\n\n  /// Registers a callback on the isolate when the memory limits are approached.\n  /// Use this to prevent V8 from crashing the process when reaching the limit.\n  ///\n  /// Calls the closure with the current heap limit and the initial heap limit.\n  /// The return value of the closure is set as the new limit.\n  pub fn add_near_heap_limit_callback\u003cC\u003e(\u0026mut self, cb: C)\n  where\n    C: FnMut(usize, usize) -\u003e usize + 'static,\n  {\n    let boxed_cb = Box::new(RefCell::new(cb));\n    let data = boxed_cb.as_ptr() as *mut c_void;\n\n    let prev = self\n      .allocations\n      .near_heap_limit_callback_data\n      .replace((boxed_cb, near_heap_limit_callback::\u003cC\u003e));\n    if let Some((_, prev_cb)) = prev {\n      self\n        .v8_isolate()\n        .remove_near_heap_limit_callback(prev_cb, 0);\n    }\n\n    self\n      .v8_isolate()\n      .add_near_heap_limit_callback(near_heap_limit_callback::\u003cC\u003e, data);\n  }\n\n  pub fn remove_near_heap_limit_callback(\u0026mut self, heap_limit: usize) {\n    if let Some((_, cb)) = self.allocations.near_heap_limit_callback_data.take()\n    {\n      self\n        .v8_isolate()\n        .remove_near_heap_limit_callback(cb, heap_limit);\n    }\n  }\n\n  fn pump_v8_message_loop(\n    \u0026self,\n    scope: \u0026mut v8::PinScope,\n  ) -\u003e Result\u003c(), Box\u003cJsError\u003e\u003e {\n    while v8::Platform::pump_message_loop(\n      \u0026v8::V8::get_current_platform(),\n      scope,\n      false, // don't block if there are no tasks\n    ) {\n      // do nothing\n    }\n\n    v8::tc_scope!(let tc_scope, scope);\n\n    tc_scope.perform_microtask_checkpoint();\n    match tc_scope.exception() {\n      None =\u003e Ok(()),\n      Some(exception) =\u003e {\n        exception_to_err_result(tc_scope, exception, false, true)\n      }\n    }\n  }\n\n  pub fn maybe_init_inspector(\u0026mut self) {\n    let inspector = \u0026mut self.inner.state.inspector.borrow_mut();\n    if inspector.is_some() {\n      return;\n    }\n\n    let context = self.main_context();\n    let isolate_ptr = unsafe { self.inner.v8_isolate.as_raw_isolate_ptr() };\n    v8::scope_with_context!(\n      scope,\n      self.inner.v8_isolate.as_mut(),\n      context.clone(),\n    );\n    let context = v8::Local::new(scope, context);\n\n    self.inner.state.has_inspector.set(true);\n    **inspector = Some(JsRuntimeInspector::new(\n      isolate_ptr,\n      scope,\n      context,\n      self.is_main_runtime,\n      None,\n    ));\n  }\n\n  /// Waits for the given value to resolve while polling the event loop.\n  ///\n  /// This future resolves when either the value is resolved or the event loop runs to\n  /// completion.\n  pub fn resolve(\n    \u0026mut self,\n    promise: v8::Global\u003cv8::Value\u003e,\n  ) -\u003e impl Future\u003cOutput = Result\u003cv8::Global\u003cv8::Value\u003e, Box\u003cJsError\u003e\u003e\u003e + use\u003c\u003e\n  {\n    scope!(scope, self);\n    Self::scoped_resolve(scope, promise)\n  }\n\n  /// Waits for the given value to resolve while polling the event loop.\n  ///\n  /// This future resolves when either the value is resolved or the event loop runs to\n  /// completion.\n  pub fn scoped_resolve(\n    scope: \u0026mut v8::PinScope,\n    promise: v8::Global\u003cv8::Value\u003e,\n  ) -\u003e impl Future\u003cOutput = Result\u003cv8::Global\u003cv8::Value\u003e, Box\u003cJsError\u003e\u003e\u003e + use\u003c\u003e\n  {\n    let promise = v8::Local::new(scope, promise);\n    if !promise.is_promise() {\n      return RcPromiseFuture::new(Ok(v8::Global::new(scope, promise)));\n    }\n    let promise = v8::Local::\u003cv8::Promise\u003e::try_from(promise).unwrap();\n    Self::resolve_promise_inner(scope, promise)\n  }\n\n  /// Waits for the given value to resolve while polling the event loop.\n  ///\n  /// This future resolves when either the value is resolved or the event loop runs to\n  /// completion.\n  #[deprecated = \"Use resolve\"]\n  pub async fn resolve_value(\n    \u0026mut self,\n    global: v8::Global\u003cv8::Value\u003e,\n  ) -\u003e Result\u003cv8::Global\u003cv8::Value\u003e, CoreError\u003e {\n    let resolve = self.resolve(global);\n    self\n      .with_event_loop_promise(resolve, PollEventLoopOptions::default())\n      .await\n  }\n\n  /// Given a promise, returns a future that resolves when it does.\n  fn resolve_promise_inner\u003c's, 'i\u003e(\n    scope: \u0026mut v8::PinScope\u003c's, 'i\u003e,\n    promise: v8::Local\u003c's, v8::Promise\u003e,\n  ) -\u003e RcPromiseFuture {\n    let future = RcPromiseFuture::default();\n    let f = future.clone();\n    watch_promise(scope, promise, move |scope, _rv, res| {\n      let res = match res {\n        Ok(l) =\u003e Ok(v8::Global::new(scope, l)),\n        Err(e) =\u003e exception_to_err_result(scope, e, true, true),\n      };\n      f.0.resolved.set(Some(res));\n      if let Some(waker) = f.0.waker.take() {\n        waker.wake();\n      }\n    });\n\n    future\n  }\n\n  /// Runs event loop to completion\n  ///\n  /// This future resolves when:\n  ///  - there are no more pending dynamic imports\n  ///  - there are no more pending ops\n  ///  - there are no more active inspector sessions (only if\n  ///    `PollEventLoopOptions.wait_for_inspector` is set to true)\n  pub async fn run_event_loop(\n    \u0026mut self,\n    poll_options: PollEventLoopOptions,\n  ) -\u003e Result\u003c(), CoreError\u003e {\n    poll_fn(|cx| self.poll_event_loop(cx, poll_options)).await\n  }\n\n  /// A utility function that run provided future concurrently with the event loop.\n  ///\n  /// If the event loop resolves while polling the future, it return an error with the text\n  /// `Promise resolution is still pending but the event loop has already resolved`\n  pub async fn with_event_loop_promise\u003c'fut, T, E\u003e(\n    \u0026mut self,\n    mut fut: impl Future\u003cOutput = Result\u003cT, E\u003e\u003e + Unpin + 'fut,\n    poll_options: PollEventLoopOptions,\n  ) -\u003e Result\u003cT, CoreError\u003e\n  where\n    CoreError: From\u003cE\u003e,\n  {\n    // Manually implement tokio::select\n    poll_fn(|cx| {\n      if let Poll::Ready(t) = fut.poll_unpin(cx) {\n        return Poll::Ready(t.map_err(|e| e.into()));\n      }\n      if let Poll::Ready(t) = self.poll_event_loop(cx, poll_options) {\n        t?;\n        if let Poll::Ready(t) = fut.poll_unpin(cx) {\n          return Poll::Ready(t.map_err(|e| e.into()));\n        }\n        return Poll::Ready(Err(\n          CoreErrorKind::PendingPromiseResolution.into_box(),\n        ));\n      }\n      Poll::Pending\n    })\n    .await\n  }\n\n  /// A utility function that run provided future concurrently with the event loop.\n  ///\n  /// If the event loop resolves while polling the future, it will continue to be polled,\n  /// regardless of whether it returned an error or success.\n  ///\n  /// Useful for interacting with local inspector session.\n  pub async fn with_event_loop_future\u003c'fut, T, E\u003e(\n    \u0026mut self,\n    mut fut: impl Future\u003cOutput = Result\u003cT, E\u003e\u003e + Unpin + 'fut,\n    poll_options: PollEventLoopOptions,\n  ) -\u003e Result\u003cT, E\u003e {\n    // Manually implement tokio::select\n    poll_fn(|cx| {\n      if let Poll::Ready(t) = fut.poll_unpin(cx) {\n        return Poll::Ready(t);\n      }\n      if let Poll::Ready(t) = self.poll_event_loop(cx, poll_options) {\n        // TODO(mmastrac): We need to ignore this error for things like the repl to behave as\n        // they did before, but this is definitely not correct. It's just something we're\n        // relying on. :(\n        _ = t;\n      }\n      Poll::Pending\n    })\n    .await\n  }\n\n  /// Runs a single tick of event loop\n  ///\n  /// If `PollEventLoopOptions.wait_for_inspector` is set to true, the event\n  /// loop will return `Poll::Pending` if there are active inspector sessions.\n  pub fn poll_event_loop(\n    \u0026mut self,\n    cx: \u0026mut Context,\n    poll_options: PollEventLoopOptions,\n  ) -\u003e Poll\u003cResult\u003c(), CoreError\u003e\u003e {\n    // SAFETY: We know this isolate is valid and non-null at this time\n    let mut isolate =\n      unsafe { v8::Isolate::from_raw_isolate_ptr(self.v8_isolate_ptr()) };\n    v8::scope!(let isolate_scope, \u0026mut isolate);\n    let context =\n      v8::Local::new(isolate_scope, self.inner.main_realm.context());\n    let mut scope = v8::ContextScope::new(isolate_scope, context);\n    self.poll_event_loop_inner(cx, \u0026mut scope, poll_options)\n  }\n\n  /// Phase-based event loop tick, matching libuv's architecture:\n  ///\n  /// Phase 1: Timers - poll expired timer callbacks\n  /// Phase 2: Pending callbacks - completed async ops, promise rejections\n  /// Phase 3: Idle/Prepare - task spawner, module progress\n  /// Phase 4: Poll - drive async reactor I/O\n  /// Phase 5: Check - setImmediate callbacks\n  /// Phase 6: Close callbacks - resource cleanup\n  ///\n  /// Microtask checkpoints run between each phase.\n  fn poll_event_loop_inner(\n    \u0026self,\n    cx: \u0026mut Context,\n    scope: \u0026mut v8::PinScope,\n    poll_options: PollEventLoopOptions,\n  ) -\u003e Poll\u003cResult\u003c(), CoreError\u003e\u003e {\n    let has_inspector = self.inner.state.has_inspector.get();\n    self.inner.state.waker.register(cx.waker());\n\n    // Pre-phase: Inspector + V8 message loop pump\n    if has_inspector {\n      self.inspector().poll_sessions_from_event_loop(cx);\n    }\n    if poll_options.pump_v8_message_loop {\n      self.pump_v8_message_loop(scope)?;\n    }\n\n    let realm = \u0026self.inner.main_realm;\n    let modules = \u0026realm.0.module_map;\n    let context_state = \u0026realm.0.context_state;\n    let exception_state = \u0026context_state.exception_state;\n\n    let mut dispatched_ops = false;\n    let mut did_work = false;\n\n    // ===== Phase 1 (Timers) =====\n    // 1a. Fire expired libuv C timers\n    if let Some(uv_inner_ptr) = context_state.uv_loop_inner.get() {\n      unsafe { (*uv_inner_ptr).run_timers() };\n    }\n    // 1b. Fire expired JS timers (direct v8::Function::call per timer)\n    did_work |= Self::dispatch_timers(cx, scope, context_state)?;\n    scope.perform_microtask_checkpoint();\n\n    // ===== Phase 2 (Pending callbacks) =====\n    // Module progress polling (before ops, matching original ordering)\n    modules.poll_progress(cx, scope)?;\n\n    // 2a. V8 task spawner tasks\n    dispatched_ops |=\n      Self::dispatch_task_spawner(cx, scope, context_state);\n\n    // 2b. Poll and resolve completed async ops\n    // NOTE: No microtask checkpoint between ops and nextTick/macrotask!\n    // This matches the old eventLoopTick behavior where ops resolve,\n    // nextTick drains, and macrotasks run all within the same JS call\n    // before any microtask checkpoint. Promise continuations (like await\n    // resumption) run only after all three have completed.\n    dispatched_ops |=\n      Self::dispatch_pending_ops(cx, scope, context_state)?;\n\n    // 2c. nextTick drain + macrotask drain (before microtask checkpoint)\n    // Only drain if there's actual work (ops dispatched, tick scheduled, or timers fired).\n    // This prevents macrotask callbacks from running on empty iterations.\n    let has_tick_scheduled = context_state.has_next_tick_scheduled.get();\n    dispatched_ops |= has_tick_scheduled;\n    if dispatched_ops || did_work || has_tick_scheduled {\n      Self::drain_next_tick_and_macrotasks(scope, context_state)?;\n    }\n\n    // 2d. Immediates (if ops or timers did work)\n    if (did_work || dispatched_ops)\n      \u0026\u0026 context_state.immediate_info.borrow().ref_count \u003e 0\n    {\n      Self::do_js_run_immediate_callbacks(scope, context_state)?;\n    }\n\n    // 2e. Handle promise rejections (after nextTick/macrotask, since\n    // unhandledrejection handlers are run in macrotask callbacks)\n    Self::dispatch_rejections(scope, context_state, exception_state)?;\n    scope.perform_microtask_checkpoint();\n\n    // ===== Phase 3 (Idle/Prepare) =====\n    if let Some(uv_inner_ptr) = context_state.uv_loop_inner.get() {\n      unsafe {\n        (*uv_inner_ptr).run_idle();\n        (*uv_inner_ptr).run_prepare();\n      };\n    }\n    scope.perform_microtask_checkpoint();\n\n    // ===== Phase 5 (Check) =====\n    // libuv check callbacks\n    if let Some(uv_inner_ptr) = context_state.uv_loop_inner.get() {\n      unsafe { (*uv_inner_ptr).run_check() };\n    }\n    scope.perform_microtask_checkpoint();\n\n    // ===== Phase 6 (Close) =====\n    exception_state.check_exception_condition(scope)?;\n    {\n      let mut phases = context_state.event_loop_phases.borrow_mut();\n      phases.run_close_callbacks();\n    }\n    if let Some(uv_inner_ptr) = context_state.uv_loop_inner.get() {\n      unsafe { (*uv_inner_ptr).run_close() };\n    }\n    scope.perform_microtask_checkpoint();\n\n    // Evaluate pending state\n    let pending_state =\n      EventLoopPendingState::new(scope, context_state, modules);\n\n    if !pending_state.is_pending() {\n      if has_inspector {\n        let inspector = self.inspector();\n        let sessions_state = inspector.sessions_state();\n\n        if poll_options.wait_for_inspector \u0026\u0026 sessions_state.has_active {\n          if sessions_state.has_blocking {\n            return Poll::Pending;\n          }\n\n          if sessions_state.has_nonblocking_wait_for_disconnect {\n            let context = self.main_context();\n            inspector.context_destroyed(scope, context);\n            self.wait_for_inspector_disconnect();\n            return Poll::Pending;\n          }\n        }\n      }\n\n      return Poll::Ready(Ok(()));\n    }\n\n    // Run immediates if not already run above and there are refed immediates pending\n    if !did_work \u0026\u0026 !dispatched_ops \u0026\u0026 pending_state.has_refed_immediates \u003e 0 {\n      Self::do_js_run_immediate_callbacks(scope, context_state)?;\n      scope.perform_microtask_checkpoint();\n    }\n\n    // Re-wake logic for next iteration\n    #[allow(clippy::suspicious_else_formatting, clippy::if_same_then_else)]\n    {\n      if pending_state.has_pending_background_tasks\n        || pending_state.has_tick_scheduled\n        || pending_state.has_outstanding_immediates\n        || pending_state.has_refed_immediates \u003e 0\n        || pending_state.has_pending_promise_events\n      {\n        self.inner.state.waker.wake();\n      } else\n      // If ops were dispatched we may have progress on pending modules that we should re-check\n      if (pending_state.has_pending_module_evaluation\n        || pending_state.has_pending_dyn_module_evaluation)\n        \u0026\u0026 dispatched_ops\n      {\n        self.inner.state.waker.wake();\n      }\n    }\n\n    if pending_state.has_pending_module_evaluation {\n      if pending_state.has_pending_ops\n        || pending_state.has_pending_dyn_imports\n        || pending_state.has_pending_dyn_module_evaluation\n        || pending_state.has_pending_background_tasks\n        || pending_state.has_pending_external_ops\n        || pending_state.has_tick_scheduled\n        || pending_state.has_refed_immediates \u003e 0\n      {\n        // pass, will be polled again\n      } else {\n        return Poll::Ready(Err(\n          CoreErrorKind::Js(find_and_report_stalled_level_await_in_any_realm(\n            scope, \u0026realm.0,\n          ))\n          .into_box(),\n        ));\n      }\n    }\n\n    if pending_state.has_pending_dyn_module_evaluation {\n      if pending_state.has_pending_ops\n        || pending_state.has_pending_dyn_imports\n        || pending_state.has_pending_background_tasks\n        || pending_state.has_pending_external_ops\n        || pending_state.has_tick_scheduled\n        || pending_state.has_refed_immediates \u003e 0\n      {\n        // pass, will be polled again\n      } else if realm.modules_idle() {\n        return Poll::Ready(Err(\n          CoreErrorKind::Js(find_and_report_stalled_level_await_in_any_realm(\n            scope, \u0026realm.0,\n          ))\n          .into_box(),\n        ));\n      } else {\n        realm.increment_modules_idle();\n        self.inner.state.waker.wake();\n      }\n    }\n\n    Poll::Pending\n  }\n}\n\nfn find_and_report_stalled_level_await_in_any_realm(\n  scope: \u0026mut v8::PinScope,\n  inner_realm: \u0026JsRealmInner,\n) -\u003e Box\u003cJsError\u003e {\n  let module_map = inner_realm.module_map();\n  let messages = module_map.find_stalled_top_level_await(scope);\n\n  if !messages.is_empty() {\n    // We are gonna print only a single message to provide a nice formatting\n    // with source line of offending promise shown. Once user fixed it, then\n    // they will get another error message for the next promise (but this\n    // situation is gonna be very rare, if ever happening).\n    let msg = v8::Local::new(scope, \u0026messages[0]);\n    let js_error = JsError::from_v8_message(scope, msg);\n    return js_error;\n  }\n\n  unreachable!(\"Expected at least one stalled top-level await\");\n}\n\nfn create_context\u003c's, 'i\u003e(\n  scope: \u0026mut v8::PinScope\u003c's, 'i, ()\u003e,\n  global_template_middlewares: \u0026[GlobalTemplateMiddlewareFn],\n  global_object_middlewares: \u0026[GlobalObjectMiddlewareFn],\n  has_snapshot: bool,\n) -\u003e v8::Local\u003c's, v8::Context\u003e {\n  let context = if has_snapshot {\n    // Try to load the 1st index first, embedder may have used 0th for something else (like node:vm).\n    v8::Context::from_snapshot(scope, 1, Default::default()).unwrap_or_else(\n      || v8::Context::from_snapshot(scope, 0, Default::default()).unwrap(),\n    )\n  } else {\n    // Set up the global object template and create context from it.\n    let mut global_object_template = v8::ObjectTemplate::new(scope);\n    for middleware in global_template_middlewares {\n      global_object_template = middleware(scope, global_object_template);\n    }\n\n    global_object_template.set_internal_field_count(2);\n    v8::Context::new(\n      scope,\n      v8::ContextOptions {\n        global_template: Some(global_object_template),\n        ..Default::default()\n      },\n    )\n  };\n\n  let scope = \u0026mut v8::ContextScope::new(scope, context);\n\n  let global = context.global(scope);\n  for middleware in global_object_middlewares {\n    middleware(scope, global);\n  }\n  context\n}\n\nimpl JsRuntimeForSnapshot {\n  /// Create a new runtime, panicking if the process fails.\n  pub fn new(options: RuntimeOptions) -\u003e JsRuntimeForSnapshot {\n    match Self::try_new(options) {\n      Ok(runtime) =\u003e runtime,\n      Err(err) =\u003e {\n        panic!(\"Failed to initialize JsRuntime for snapshotting: {:?}\", err);\n      }\n    }\n  }\n\n  /// Try to create a new runtime, returning an error if the process fails.\n  pub fn try_new(\n    mut options: RuntimeOptions,\n  ) -\u003e Result\u003cJsRuntimeForSnapshot, CoreError\u003e {\n    setup::init_v8(\n      options.v8_platform.take(),\n      true,\n      options.unsafe_expose_natives_and_gc(),\n    );\n\n    let runtime = JsRuntime::new_inner(options, true)?;\n    Ok(JsRuntimeForSnapshot(runtime))\n  }\n\n  /// Takes a snapshot and consumes the runtime.\n  ///\n  /// `Error` can usually be downcast to `JsError`.\n  pub fn snapshot(mut self) -\u003e Box\u003c[u8]\u003e {\n    // Ensure there are no live inspectors to prevent crashes.\n    self.inner.prepare_for_cleanup();\n    let original_sources =\n      std::mem::take(\u0026mut self.0.allocations.original_sources);\n    let external_strings = original_sources\n      .iter()\n      .map(|s| s.as_str().as_bytes())\n      .collect();\n    let realm = JsRealm::clone(\u0026self.inner.main_realm);\n\n    // Set the context to be snapshot's default context\n    {\n      jsrealm::context_scope!(scope, realm, self.v8_isolate());\n      let default_context = v8::Context::new(scope, Default::default());\n      scope.set_default_context(default_context);\n\n      let local_context = v8::Local::new(scope, realm.context());\n      scope.add_context(local_context);\n    }\n\n    // Borrow the source maps during the snapshot to avoid copies\n    let source_maps = self\n      .inner\n      .state\n      .source_mapper\n      .borrow_mut()\n      .take_ext_source_maps();\n    let mut ext_source_maps = HashMap::with_capacity(source_maps.len());\n    for (k, v) in \u0026source_maps {\n      ext_source_maps.insert(k.as_static_str().unwrap(), v.as_ref());\n    }\n\n    // Serialize the module map and store its data in the snapshot.\n    // TODO(mmastrac): This should deconstruct the realm into sidecar data rather than\n    // extracting it from the realm and then tearing the realm down. IE, this should\n    // probably be a method on `JsRealm` with a self-consuming parameter signature:\n    // `fn into_sidecar_data(self) -\u003e ...`.\n    let sidecar_data = {\n      let mut data_store = SnapshotStoreDataStore::default();\n      let module_map_data = {\n        let module_map = realm.0.module_map();\n        module_map.serialize_for_snapshotting(\u0026mut data_store)\n      };\n      let function_templates_data = {\n        let function_templates = realm.0.function_templates();\n        let f = std::mem::take(\u0026mut *function_templates.borrow_mut());\n\n        f.serialize_for_snapshotting(\u0026mut data_store)\n      };\n      let maybe_js_handled_promise_rejection_cb = {\n        let context_state = \u0026realm.0.context_state;\n        let exception_state = \u0026context_state.exception_state;\n        exception_state\n          .js_handled_promise_rejection_cb\n          .borrow()\n          .clone()\n      }\n      .map(|cb| data_store.register(cb));\n\n      let ext_import_meta_proto = realm\n        .0\n        .context_state\n        .ext_import_meta_proto\n        .borrow()\n        .clone()\n        .map(|p| data_store.register(p));\n\n      let snapshotted_data = SnapshottedData {\n        module_map_data,\n        function_templates_data,\n        op_count: self.inner.op_count,\n        addl_refs_count: self.inner.addl_refs_count,\n        source_count: self.inner.source_count,\n        extensions: self.inner.extensions.clone(),\n        js_handled_promise_rejection_cb: maybe_js_handled_promise_rejection_cb,\n        ext_import_meta_proto,\n        ext_source_maps,\n        external_strings,\n      };\n\n      jsrealm::context_scope!(scope, realm, self.v8_isolate());\n      snapshot::store_snapshotted_data_for_snapshot(\n        scope,\n        realm.context().clone(),\n        snapshotted_data,\n        data_store,\n      )\n    };\n    drop(realm);\n\n    let v8_data = self\n      .0\n      .inner\n      .prepare_for_snapshot()\n      .create_blob(v8::FunctionCodeHandling::Keep)\n      .unwrap();\n\n    snapshot::serialize(v8_data, sidecar_data)\n  }\n}\n\n#[derive(Clone, Copy, PartialEq, Eq, Debug)]\npub(crate) struct EventLoopPendingState {\n  has_pending_ops: bool,\n  has_pending_refed_ops: bool,\n  has_pending_dyn_imports: bool,\n  has_pending_dyn_module_evaluation: bool,\n  has_pending_module_evaluation: bool,\n  has_pending_background_tasks: bool,\n  has_tick_scheduled: bool,\n  has_pending_promise_events: bool,\n  has_pending_external_ops: bool,\n  has_outstanding_immediates: bool,\n  has_refed_immediates: u32,\n}\n\nimpl EventLoopPendingState {\n  /// Collect event loop state from all the sub-states.\n  pub fn new(\n    scope: \u0026mut v8::PinScope\u003c()\u003e,\n    state: \u0026ContextState,\n    modules: \u0026ModuleMap,\n  ) -\u003e Self {\n    let num_unrefed_ops = state.unrefed_ops.borrow().len();\n    let num_pending_ops = state.pending_ops.len();\n    let has_pending_tasks = state.task_spawner_factory.has_pending_tasks();\n    let has_pending_timers = !state.timers.is_empty();\n    let has_pending_refed_timers = state.timers.has_pending_timers();\n    let has_pending_dyn_imports = modules.has_pending_dynamic_imports();\n    let has_pending_dyn_module_evaluation =\n      modules.has_pending_dyn_module_evaluation();\n    let has_pending_module_evaluation = modules.has_pending_module_evaluation();\n    let has_pending_promise_events = !state\n      .exception_state\n      .pending_promise_rejections\n      .borrow()\n      .is_empty()\n      || !state\n        .exception_state\n        .pending_handled_promise_rejections\n        .borrow()\n        .is_empty();\n    let has_pending_refed_ops = has_pending_tasks\n      || has_pending_refed_timers\n      || num_pending_ops \u003e num_unrefed_ops;\n    let (has_outstanding_immediates, has_refed_immediates) = {\n      let info = state.immediate_info.borrow();\n      (info.has_outstanding, info.ref_count)\n    };\n    EventLoopPendingState {\n      has_pending_ops: has_pending_refed_ops\n        || has_pending_timers\n        || (num_pending_ops \u003e 0),\n      has_pending_refed_ops,\n      has_pending_dyn_imports,\n      has_pending_dyn_module_evaluation,\n      has_pending_module_evaluation,\n      has_pending_background_tasks: scope.has_pending_background_tasks(),\n      has_tick_scheduled: state.has_next_tick_scheduled.get(),\n      has_pending_promise_events,\n      has_pending_external_ops: state.external_ops_tracker.has_pending_ops(),\n      has_outstanding_immediates,\n      has_refed_immediates,\n    }\n  }\n\n  /// Collect event loop state from all the states stored in the scope.\n  pub fn new_from_scope(scope: \u0026mut v8::PinScope) -\u003e Self {\n    let module_map = JsRealm::module_map_from(scope);\n    let context_state = JsRealm::state_from_scope(scope);\n    Self::new(scope, \u0026context_state, \u0026module_map)\n  }\n\n  pub fn is_pending(\u0026self) -\u003e bool {\n    self.has_pending_refed_ops\n      || self.has_pending_dyn_imports\n      || self.has_pending_dyn_module_evaluation\n      || self.has_pending_module_evaluation\n      || self.has_pending_background_tasks\n      || self.has_tick_scheduled\n      || self.has_refed_immediates \u003e 0\n      || self.has_pending_promise_events\n      || self.has_pending_external_ops\n  }\n}\n\nextern \"C\" fn near_heap_limit_callback\u003cF\u003e(\n  data: *mut c_void,\n  current_heap_limit: usize,\n  initial_heap_limit: usize,\n) -\u003e usize\nwhere\n  F: FnMut(usize, usize) -\u003e usize,\n{\n  // SAFETY: The data is a pointer to the Rust callback function. It is stored\n  // in `JsRuntime::allocations` and thus is guaranteed to outlive the isolate.\n  let callback = unsafe { \u0026mut *(data as *mut F) };\n  callback(current_heap_limit, initial_heap_limit)\n}\n\nimpl JsRuntimeState {\n  pub(crate) fn inspector(\u0026self) -\u003e Rc\u003cJsRuntimeInspector\u003e {\n    self.inspector.borrow().as_ref().unwrap().clone()\n  }\n\n  /// Called by `bindings::host_import_module_dynamically_callback`\n  /// after initiating new dynamic import load.\n  pub fn notify_new_dynamic_import(\u0026self) {\n    // Notify event loop to poll again soon.\n    self.waker.wake();\n  }\n\n  /// Performs an action with the inspector, if we have one\n  pub(crate) fn with_inspector\u003cT\u003e(\n    \u0026self,\n    mut f: impl FnMut(\u0026JsRuntimeInspector) -\u003e T,\n  ) -\u003e Option\u003cT\u003e {\n    // Fast path\n    if !self.has_inspector.get() {\n      return None;\n    }\n    self\n      .inspector\n      .borrow()\n      .as_ref()\n      .map(|inspector| f(inspector))\n  }\n}\n\n// Related to module loading\nimpl JsRuntime {\n  #[cfg(test)]\n  pub(crate) fn instantiate_module(\n    \u0026mut self,\n    id: ModuleId,\n  ) -\u003e Result\u003c(), v8::Global\u003cv8::Value\u003e\u003e {\n    let isolate = \u0026mut *self.inner.v8_isolate;\n    let realm = JsRealm::clone(\u0026self.inner.main_realm);\n    jsrealm::context_scope!(scope, realm, isolate);\n    realm.instantiate_module(scope, id)\n  }\n\n  /// Evaluates an already instantiated ES module.\n  ///\n  /// Returns a future that resolves when module promise resolves.\n  /// Implementors must manually call [`JsRuntime::run_event_loop`] to drive\n  /// module evaluation future.\n  ///\n  /// Modules with top-level await are treated like promises, so a `throw` in the top-level\n  /// block of a module is treated as an unhandled rejection. These rejections are provided to\n  /// the unhandled promise rejection handler, which has the opportunity to pass them off to\n  /// error-handling code. If those rejections are not handled (indicated by a `false` return\n  /// from that unhandled promise rejection handler), then the runtime will terminate.\n  ///\n  /// The future provided by `mod_evaluate` will only return errors in the case where\n  /// the runtime is shutdown and no longer available to provide unhandled rejection\n  /// information.\n  ///\n  /// This function panics if module has not been instantiated.\n  pub fn mod_evaluate(\n    \u0026mut self,\n    id: ModuleId,\n  ) -\u003e impl Future\u003cOutput = Result\u003c(), CoreError\u003e\u003e + use\u003c\u003e {\n    let isolate = \u0026mut *self.inner.v8_isolate;\n    let realm = \u0026self.inner.main_realm;\n    jsrealm::context_scope!(scope, realm, isolate);\n    self.inner.main_realm.0.module_map.mod_evaluate(scope, id)\n  }\n\n  /// Asynchronously load specified module and all of its dependencies.\n  ///\n  /// The module will be marked as \"main\", and because of that\n  /// \"import.meta.main\" will return true when checked inside that module.\n  ///\n  /// The source may be any type that implements the internal [`IntoModuleCodeString`] trait, but\n  /// it is highly recommended that embedders use the [`ascii_str!`] to generate the fastest version\n  /// of strings for v8 to handle. If the strings are not static, you may also pass a [`String`]\n  /// generated by the [`format!`] macro.\n  ///\n  /// User must call [`JsRuntime::mod_evaluate`] with returned `ModuleId`\n  /// manually after load is finished.\n  pub async fn load_main_es_module_from_code(\n    \u0026mut self,\n    specifier: \u0026ModuleSpecifier,\n    code: impl IntoModuleCodeString,\n  ) -\u003e Result\u003cModuleId, CoreError\u003e {\n    let isolate = \u0026mut self.inner.v8_isolate;\n    self\n      .inner\n      .main_realm\n      .load_main_es_module_from_code(\n        isolate,\n        specifier,\n        Some(code.into_module_code()),\n      )\n      .await\n  }\n\n  /// Asynchronously load specified module and all of its dependencies, retrieving\n  /// the module from the supplied [`ModuleLoader`].\n  ///\n  /// The module will be marked as \"main\", and because of that\n  /// \"import.meta.main\" will return true when checked inside that module.\n  ///\n  /// User must call [`JsRuntime::mod_evaluate`] with returned `ModuleId`\n  /// manually after load is finished.\n  pub async fn load_main_es_module(\n    \u0026mut self,\n    specifier: \u0026ModuleSpecifier,\n  ) -\u003e Result\u003cModuleId, CoreError\u003e {\n    let isolate = \u0026mut self.inner.v8_isolate;\n    self\n      .inner\n      .main_realm\n      .load_main_es_module_from_code(isolate, specifier, None)\n      .await\n  }\n\n  /// Asynchronously load specified ES module and all of its dependencies from the\n  /// provided source.\n  ///\n  /// This method is meant to be used when loading some utility code that\n  /// might be later imported by the main module (ie. an entry point module).\n  ///\n  /// The source may be any type that implements the internal [`IntoModuleCodeString`] trait, but\n  /// it is highly recommended that embedders use the [`ascii_str!`] to generate the fastest version\n  /// of strings for v8 to handle. If the strings are not static, you may also pass a [`String`]\n  /// generated by the [`format!`] macro.\n  ///\n  /// User must call [`JsRuntime::mod_evaluate`] with returned `ModuleId`\n  /// manually after load is finished.\n  pub async fn load_side_es_module_from_code(\n    \u0026mut self,\n    specifier: \u0026ModuleSpecifier,\n    code: impl IntoModuleCodeString,\n  ) -\u003e Result\u003cModuleId, CoreError\u003e {\n    let isolate = \u0026mut self.inner.v8_isolate;\n    self\n      .inner\n      .main_realm\n      .load_side_es_module_from_code(\n        isolate,\n        specifier.to_string(),\n        Some(code.into_module_code()),\n      )\n      .await\n  }\n\n  /// Asynchronously load specified ES module and all of its dependencies, retrieving\n  /// the module from the supplied [`ModuleLoader`].\n  ///\n  /// This method is meant to be used when loading some utility code that\n  /// might be later imported by the main module (ie. an entry point module).\n  ///\n  /// User must call [`JsRuntime::mod_evaluate`] with returned `ModuleId`\n  /// manually after load is finished.\n  pub async fn load_side_es_module(\n    \u0026mut self,\n    specifier: \u0026ModuleSpecifier,\n  ) -\u003e Result\u003cModuleId, CoreError\u003e {\n    let isolate = \u0026mut self.inner.v8_isolate;\n    self\n      .inner\n      .main_realm\n      .load_side_es_module_from_code(isolate, specifier.to_string(), None)\n      .await\n  }\n\n  /// Load and evaluate an ES module provided the specifier and source code.\n  ///\n  /// The module should not have Top-Level Await (that is, it should be\n  /// possible to evaluate it synchronously).\n  ///\n  /// It is caller's responsibility to ensure that not duplicate specifiers are\n  /// passed to this method.\n  pub fn lazy_load_es_module_with_code(\n    \u0026mut self,\n    specifier: impl IntoModuleName,\n    code: impl IntoModuleCodeString,\n  ) -\u003e Result\u003cv8::Global\u003cv8::Value\u003e, CoreError\u003e {\n    let isolate = \u0026mut self.inner.v8_isolate;\n    self.inner.main_realm.lazy_load_es_module_with_code(\n      isolate,\n      specifier.into_module_name(),\n      code.into_module_code(),\n    )\n  }\n\n  fn do_js_run_immediate_callbacks\u003c's, 'i\u003e(\n    scope: \u0026mut v8::PinScope\u003c's, 'i\u003e,\n    context_state: \u0026ContextState,\n  ) -\u003e Result\u003c(), Box\u003cJsError\u003e\u003e {\n    v8::tc_scope!(let tc_scope, scope);\n\n    let undefined = v8::undefined(tc_scope).into();\n    let run_immediate_callbacks_cb =\n      context_state.run_immediate_callbacks_cb.borrow();\n    let run_immediate_callbacks_cb =\n      run_immediate_callbacks_cb.as_ref().unwrap().open(tc_scope);\n\n    run_immediate_callbacks_cb.call(tc_scope, undefined, \u0026[]);\n\n    if let Some(exception) = tc_scope.exception() {\n      let e: Result\u003c(), Box\u003cJsError\u003e\u003e =\n        exception_to_err_result(tc_scope, exception, false, true);\n      return e;\n    }\n    Ok(())\n  }\n\n  /// Phase 1 (Timers): Poll JS WebTimers, dispatch each callback directly\n  /// via v8::Function::call. Microtask checkpoint + nextTick drain between\n  /// each timer callback.\n  fn dispatch_timers\u003c's, 'i\u003e(\n    cx: \u0026mut Context,\n    scope: \u0026mut v8::PinScope\u003c's, 'i\u003e,\n    context_state: \u0026ContextState,\n  ) -\u003e Result\u003cbool, Box\u003cJsError\u003e\u003e {\n    let timers = match context_state.timers.poll_timers(cx) {\n      Poll::Ready(timers) =\u003e timers,\n      _ =\u003e return Ok(false),\n    };\n\n    if timers.is_empty() {\n      return Ok(false);\n    }\n\n    let traces_enabled = context_state.activity_traces.is_enabled();\n    let undefined: v8::Local\u003cv8::Value\u003e = v8::undefined(scope).into();\n\n    for (timer_id, (callback, depth)) in \u0026timers {\n      if traces_enabled {\n        context_state\n          .activity_traces\n          .complete(RuntimeActivityType::Timer, *timer_id as _);\n      }\n\n      // Set timer depth via JS setter\n      {\n        let set_timer_depth_cb =\n          context_state.js_set_timer_depth_cb.borrow();\n        let set_timer_depth_fn =\n          set_timer_depth_cb.as_ref().unwrap().open(scope);\n        let depth_val = v8::Integer::new(scope, *depth as i32);\n        set_timer_depth_fn.call(scope, undefined, \u0026[depth_val.into()]);\n      }\n\n      // Call the timer callback directly\n      {\n        v8::tc_scope!(let tc_scope, scope);\n        let cb = callback.open(tc_scope);\n        cb.call(tc_scope, undefined, \u0026[]);\n\n        if let Some(exception) = tc_scope.exception() {\n          // Report exception but don't abort the timer loop.\n          // Globalize the exception value, then get report fn and call it.\n          let exc_global = v8::Global::new(tc_scope, exception);\n          {\n            let report_exception_cb =\n              context_state.js_report_exception_cb.borrow();\n            if let Some(report_fn_global) = report_exception_cb.as_ref() {\n              let report_fn = report_fn_global.open(tc_scope);\n              let exc_local = v8::Local::new(tc_scope, \u0026exc_global);\n              report_fn.call(tc_scope, undefined, \u0026[exc_local]);\n            }\n          }\n        }\n      }\n\n      // Microtask checkpoint between each timer\n      scope.perform_microtask_checkpoint();\n\n      // Drain nextTick between each timer callback\n      {\n        let has_tick = context_state.has_next_tick_scheduled.get();\n        let drain_cb =\n          context_state.js_drain_next_tick_and_macrotasks_cb.borrow();\n        let drain_fn = drain_cb.as_ref().unwrap().open(scope);\n        let has_tick_val = v8::Boolean::new(scope, has_tick);\n        drain_fn.call(scope, undefined, \u0026[has_tick_val.into()]);\n      }\n\n      scope.perform_microtask_checkpoint();\n    }\n\n    // Reset timer depth to 0 after all timers\n    {\n      let set_timer_depth_cb =\n        context_state.js_set_timer_depth_cb.borrow();\n      let set_timer_depth_fn =\n        set_timer_depth_cb.as_ref().unwrap().open(scope);\n      let zero = v8::Integer::new(scope, 0);\n      set_timer_depth_fn.call(scope, undefined, \u0026[zero.into()]);\n    }\n\n    Ok(true)\n  }\n\n  /// Phase 2a: Poll and dispatch V8 task spawner tasks.\n  fn dispatch_task_spawner(\n    cx: \u0026mut Context,\n    scope: \u0026mut v8::PinScope,\n    context_state: \u0026ContextState,\n  ) -\u003e bool {\n    let mut dispatched = false;\n    let mut retries = 3;\n    while let Poll::Ready(tasks) =\n      context_state.task_spawner_factory.poll_inner(cx)\n    {\n      dispatched = true;\n      for task in tasks {\n        task(scope);\n      }\n      scope.perform_microtask_checkpoint();\n\n      retries -= 1;\n      if retries == 0 {\n        cx.waker().wake_by_ref();\n        break;\n      }\n    }\n    dispatched\n  }\n\n  /// Phase 2b: Poll completed async ops and batch-resolve via JS __resolveOps.\n  fn dispatch_pending_ops\u003c's, 'i\u003e(\n    cx: \u0026mut Context,\n    scope: \u0026mut v8::PinScope\u003c's, 'i\u003e,\n    context_state: \u0026ContextState,\n  ) -\u003e Result\u003cbool, Box\u003cJsError\u003e\u003e {\n    const MAX_VEC_SIZE_FOR_OPS: usize = 1024;\n\n    let mut args: SmallVec\u003c[v8::Local\u003cv8::Value\u003e; 32]\u003e =\n      SmallVec::with_capacity(32);\n\n    loop {\n      if args.len() \u003e= MAX_VEC_SIZE_FOR_OPS {\n        cx.waker().wake_by_ref();\n        break;\n      }\n\n      let Poll::Ready((promise_id, op_id, res)) =\n        context_state.pending_ops.poll_ready(cx)\n      else {\n        break;\n      };\n\n      let res = res.unwrap(scope);\n\n      {\n        let op_ctx = \u0026context_state.op_ctxs[op_id as usize];\n        if op_ctx.metrics_enabled() {\n          if res.is_ok() {\n            dispatch_metrics_async(op_ctx, OpMetricsEvent::CompletedAsync);\n          } else {\n            dispatch_metrics_async(op_ctx, OpMetricsEvent::ErrorAsync);\n          }\n        }\n      }\n\n      context_state.unrefed_ops.borrow_mut().remove(\u0026promise_id);\n      context_state\n        .activity_traces\n        .complete(RuntimeActivityType::AsyncOp, promise_id as _);\n      args.push(v8::Integer::new(scope, promise_id).into());\n      args.push(v8::Boolean::new(scope, res.is_ok()).into());\n      args.push(res.unwrap_or_else(std::convert::identity));\n    }\n\n    if args.is_empty() {\n      return Ok(false);\n    }\n\n    let undefined: v8::Local\u003cv8::Value\u003e = v8::undefined(scope).into();\n\n    v8::tc_scope!(let tc_scope, scope);\n\n    let resolve_ops_cb = context_state.js_resolve_ops_cb.borrow();\n    let resolve_ops_fn = resolve_ops_cb.as_ref().unwrap().open(tc_scope);\n    resolve_ops_fn.call(tc_scope, undefined, args.as_slice());\n\n    if let Some(exception) = tc_scope.exception() {\n      return exception_to_err_result(tc_scope, exception, false, true);\n    }\n    if tc_scope.has_terminated() || tc_scope.is_execution_terminating() {\n      return Ok(false);\n    }\n\n    Ok(true)\n  }\n\n  /// Phase 2c: Handle promise rejections.\n  fn dispatch_rejections\u003c's, 'i\u003e(\n    scope: \u0026mut v8::PinScope\u003c's, 'i\u003e,\n    context_state: \u0026ContextState,\n    exception_state: \u0026ExceptionState,\n  ) -\u003e Result\u003c(), Box\u003cJsError\u003e\u003e {\n    let undefined: v8::Local\u003cv8::Value\u003e = v8::undefined(scope).into();\n\n    // First handle \"handled\" rejections\n    while let Some((promise, result)) = exception_state\n      .pending_handled_promise_rejections\n      .borrow_mut()\n      .pop_front()\n    {\n      if let Some(handler) = exception_state\n        .js_handled_promise_rejection_cb\n        .borrow()\n        .as_ref()\n      {\n        let function = handler.open(scope);\n        let args = [\n          v8::Local::new(scope, promise).into(),\n          v8::Local::new(scope, result),\n        ];\n        function.call(scope, undefined, \u0026args);\n      }\n    }\n\n    // Then handle unhandled rejections\n    if exception_state\n      .pending_promise_rejections\n      .borrow()\n      .is_empty()\n    {\n      return Ok(());\n    }\n\n    let mut pending_rejections =\n      exception_state.pending_promise_rejections.borrow_mut();\n    let mut rejections = VecDeque::default();\n    std::mem::swap(\u0026mut *pending_rejections, \u0026mut rejections);\n    drop(pending_rejections);\n\n    let mut args: SmallVec\u003c[v8::Local\u003cv8::Value\u003e; 16]\u003e =\n      SmallVec::with_capacity(rejections.len() * 2);\n    for rejection in rejections.into_iter() {\n      args.push(v8::Local::new(scope, rejection.0).into());\n      args.push(v8::Local::new(scope, rejection.1));\n    }\n\n    v8::tc_scope!(let tc_scope, scope);\n\n    let handle_rejections_cb =\n      context_state.js_handle_rejections_cb.borrow();\n    let handle_rejections_fn =\n      handle_rejections_cb.as_ref().unwrap().open(tc_scope);\n    handle_rejections_fn.call(tc_scope, undefined, args.as_slice());\n\n    if let Some(exception) = tc_scope.exception() {\n      return exception_to_err_result(tc_scope, exception, false, true);\n    }\n\n    Ok(())\n  }\n\n  /// Phase 5a: Drain nextTick queue and macrotask queue.\n  fn drain_next_tick_and_macrotasks\u003c's, 'i\u003e(\n    scope: \u0026mut v8::PinScope\u003c's, 'i\u003e,\n    context_state: \u0026ContextState,\n  ) -\u003e Result\u003c(), Box\u003cJsError\u003e\u003e {\n    let undefined: v8::Local\u003cv8::Value\u003e = v8::undefined(scope).into();\n    let has_tick_scheduled = context_state.has_next_tick_scheduled.get();\n\n    v8::tc_scope!(let tc_scope, scope);\n\n    let drain_cb =\n      context_state.js_drain_next_tick_and_macrotasks_cb.borrow();\n    let drain_fn = drain_cb.as_ref().unwrap().open(tc_scope);\n    let has_tick_val = v8::Boolean::new(tc_scope, has_tick_scheduled);\n    drain_fn.call(tc_scope, undefined, \u0026[has_tick_val.into()]);\n\n    if let Some(exception) = tc_scope.exception() {\n      return exception_to_err_result(tc_scope, exception, false, true);\n    }\n\n    Ok(())\n  }\n}\n\nfn mark_as_loaded_from_fs_during_snapshot(\n  files_loaded: \u0026mut Vec\u003c\u0026'static str\u003e,\n  source: \u0026ExtensionFileSourceCode,\n) {\n  #[allow(deprecated)]\n  if let ExtensionFileSourceCode::LoadedFromFsDuringSnapshot(path) = source {\n    files_loaded.push(path);\n  }\n}\n\n[file map]\n  impl ManuallyDropRc: L113-118\n  func clone: L115-117\n  impl Deref: L120-125\n  func deref: L122-124\n  impl DerefMut: L127-131\n  func deref_mut: L128-130\n  impl InnerIsolateState: L156-204\n  func prepare_for_cleanup: L160-173\n  func cleanup: L175-188\n  func prepare_for_snapshot: L190-203\n  impl Drop: L206-224\n  func drop: L207-223\n  impl InitMode: L237-256\n  func from_options: L238-245\n  func needs_ops_bindings: L248-255\n  type PromiseFuture: L259-262\n  type RcPromiseFuture: L265-274\n  impl RcPromiseFuture: L267-274\n  func new: L268-273\n  impl Future: L276-289\n  func poll: L279-288\n  type JsRuntime: L343-352\n  type JsRuntimeForSnapshot: L355-363\n  impl Deref: L357-363\n  func deref: L360-362\n  impl DerefMut: L365-369\n  func deref_mut: L366-368\n  type CrossIsolateStore: L371-376\n  type CrossIsolateStoreInner: L373-376\n  impl CrossIsolateStore: L378-391\n  impl Default: L393-400\n  func default: L394-399\n  impl Clone: L402-406\n  func clone: L403-405\n  type JsRuntimeState: L415-436\n  type RuntimeOptions: L439-546\n  impl RuntimeOptions: L548-558\n  func unsafe_expose_natives_and_gc: L550-552\n  func unsafe_expose_natives_and_gc: L555-557\n  type PollEventLoopOptions: L561-564\n  impl Default: L566-573\n  func default: L567-572\n  type CreateRealmOptions: L576-583\n  impl JsRuntime: L596\n  func init_platform: L601-603\n  func init_platform: L614-619\n  func new: L623-633\n  func try_new: L637-644\n  func op_state_from: L658-661\n  func op_metadata: L669-678\n  func new_inner: L680-2168\n  func lazy_init_extensions: L1093-1135\n  func set_eval_context_code_cache_cbs: L1137-1155\n  func main_context: L1164-1166\n  func v8_isolate: L1174-1176\n  func v8_isolate_ptr: L1179-1181\n  func inspector: L1184-1186\n  func wait_for_inspector_disconnect: L1189-1198\n  func runtime_activity_stats_factory: L1200-1205\n  func execute_virtual_ops_module: L1215-1238\n  func execute_builtin_sources: L1246-1277\n  func init_extension_js_inner: L1280-1374\n  func init_extension_js: L1377-1392\n  func eval: L1394-1406\n  func store_js_callbacks: L1410-1540\n  func op_state: L1544-1546\n  func op_names: L1549-1552\n  func execute_script: L1571-1582\n  func call: L1591-1597\n  func scoped_call: L1606-1612\n  func call_with_args: L1621-1629\n  func scoped_call_with_args: L1638-1676\n  func call_and_await: L1682-1690\n  func call_with_args_and_await: L1696-1705\n  func get_module_namespace: L1711-1720\n  func add_near_heap_limit_callback: L1727-1747\n  func remove_near_heap_limit_callback: L1749-1756\n  func pump_v8_message_loop: L1758-1779\n  func maybe_init_inspector: L1781-1804\n  func resolve: L1810-1817\n  func scoped_resolve: L1823-1834\n  func resolve_value: L1841-1849\n  func resolve_promise_inner: L1852-1870\n  func run_event_loop: L1879-1884\n  func with_event_loop_promise: L1890-1915\n  func with_event_loop_future: L1923-1942\n  func poll_event_loop: L1948-1961\n  func poll_event_loop_inner: L1973-2167\n  func find_and_report_stalled_level_await_in_any_realm: L2170-2188\n  func create_context: L2190-2225\n  impl JsRuntimeForSnapshot: L2227-2355\n  func new: L2229-2236\n  func try_new: L2239-2250\n  func snapshot: L2255-2354\n  impl EventLoopPendingState: L2372-2440\n  func new: L2374-2420\n  func new_from_scope: L2423-2427\n  func is_pending: L2429-2439\n  impl JsRuntimeState: L2456-2483\n  func notify_new_dynamic_import: L2463-2466\n  impl JsRuntime: L2486-2934\n  func mod_evaluate: L2515-2523\n  func load_main_es_module_from_code: L2537-2552\n  func load_main_es_module: L2562-2572\n  func load_side_es_module_from_code: L2587-2602\n  func load_side_es_module: L2612-2622\n  func lazy_load_es_module_with_code: L2631-2642\n  func do_js_run_immediate_callbacks: L2644-2664\n  func dispatch_timers: L2669-2752\n  func dispatch_task_spawner: L2755-2778\n  func dispatch_pending_ops: L2781-2845\n  func dispatch_rejections: L2848-2910\n  func drain_next_tick_and_macrotasks: L2913-2933\n  func mark_as_loaded_from_fs_during_snapshot: L2936-2944\n",
      "is_error": false,
      "duration_ms": 2
    }
  ],
  "verified": false,
  "stats": {
    "api_calls": 16,
    "input_tokens": 233651,
    "output_tokens": 3545,
    "elapsed_ms": 47222,
    "cost_usd": 0.754128
  },
  "created": "2026-02-18T17:00:48.856395+05:30"
}